{"version":3,"file":"can-histogram.min.js","sources":["../src/utils/PositionUtils.js","../src/Histogram.js","../src/utils/Observable.js","../src/HistogramDefaults.js","../src/HistogramData.js","../src/selection/HistogramHandle.js","../src/selection/HistogramSelectionRenderer.js","../src/HistogramRenderer.js","../src/selection/HistogramSelection.js","../src/selection/MultipleHistogramSelectionImpl.js","../src/selection/DefaultHistogramSelectionImpl.js","../src/selection/FilterHistogramSelectionImpl.js","../src/selection/InvertedFilterHistogramSelectionImpl.js","../src/selection/HistogramSelectionFactory.js"],"sourcesContent":["/**\n * @public\n * Returns handle positions offsets so that labels don't conflict visually\n * @param {HistogramData} histogramData \n * @returns {Array} label offsets\n */\nexport function getHandlePositionOffsets(handle1, handle2, maskPadding, width){\n    var label1Box = handle1.getLabelBox();\n    var label2Box = handle2.getLabelBox();\n\n    // calculate conflict number\n    var conflictDiff = label2Box.x - (label1Box.x + label1Box.width)-maskPadding;\n    // and handle if there is not enough space\n    if (conflictDiff<0){\n        // pos1 diff to the left\n        var posDiff1 = conflictDiff/2;\n        // pos2 diff to to right\n        var posDiff2 = conflictDiff/2;\n\n        // position left to 0 if position would be lower than 0\n        var xMin = label1Box.x+posDiff1;\n        if (xMin < 0){\n            posDiff1 = label1Box.x; \n            // also shift right label so we keep it visible\n            posDiff2 = posDiff2*2\n        }\n\n        // same with max value\n        var xMax = label2Box.x+label2Box.width-posDiff2;\n        if (xMax > width){\n            posDiff2 += xMax-width; \n            posDiff1 = posDiff1*2\n        }\n        return [posDiff1, -posDiff2];                  \n    }\n\n    return [0,0];\n}","import * as d3 from \"d3\";\r\nimport Observable from \"./utils/Observable\";\r\nimport * as Defaults from \"./HistogramDefaults\";\r\nimport HistogramData from \"./HistogramData\";\r\nimport HistogramRenderer from \"./HistogramRenderer\";\r\nimport HistogramSelectionFactory from \"./selection/HistogramSelectionFactory\"\r\nimport {SelectionTypes} from \"./selection/HistogramSelection\";\r\n\r\n/**\r\n * @private \r\n * @param {*} optionValue option value \r\n * @param {*} defaultOptionValue default option value \r\n * @returns option or default option value \r\n */\r\nfunction getOptionValue(optionValue, defaultOptionValue) {\r\n\treturn typeof optionValue == \"undefined\" ? defaultOptionValue : optionValue;\r\n}\r\n\r\n/**\r\n * @class\r\n * Main histogram class\r\n * @param {Object} options\r\n */\r\nclass Histogram {\r\n\tconstructor(options) {\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * Options property exposing widget's options\r\n\t\t */\r\n\t\tthis._options = {};\r\n\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * prompt handler\r\n\t\t */\r\n\t\tthis._options.promptHandler = options.promptHandler || null;\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * Width of the widget\r\n\t\t */\r\n\t\tthis._options.width = getOptionValue(options.width, Defaults.WIDTH);\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * Height of the widget\r\n\t\t */\r\n\t\tthis._options.height = getOptionValue(options.height, Defaults.HEIGHT);\r\n\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * Format for widget labels \r\n\t\t */\r\n\t\tthis._options.format = getOptionValue(options.format, null);\r\n\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * Inactive bar color \r\n\t\t */\r\n\t\tthis._options.inactiveBarColor = getOptionValue(options.inactiveBarColor, Defaults.INACTIVE_BAR_COLOR);\r\n\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * Inactive bar opacity \r\n\t\t */\r\n\t\tthis._options.inactiveBarOpacity = getOptionValue(options.inactiveBarOpacity, Defaults.INACTIVE_BAR_OPACITY);\r\n\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * Over bar color \r\n\t\t */\r\n\t\tthis._options.overSelectionColor = getOptionValue(options.overSelectionColor, Defaults.OVER_SELECTION_COLOR);\r\n\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * Over selection opacity \r\n\t\t */\r\n\t\tthis._options.overSelectionOpacity = getOptionValue(options.overSelectionOpacity, Defaults.OVER_SELECTION_OPACITY);\r\n\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * Selection color \r\n\t\t */\r\n\t\tthis._options.selectionColor = getOptionValue(options.selectionColor, Defaults.SELECTION_COLOR);\r\n\t\t\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * Enable selection toggle \r\n\t\t */\r\n\t\tthis._options.enableSelectionToggle = getOptionValue(options.enableSelectionToggle, Defaults.ENABLE_SELECTION_TOGGLE);\r\n\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * Font size\r\n\t\t */\r\n\t\tthis._options.fontSize = getOptionValue(options.fontSize, Defaults.FONT_SIZE);\r\n\r\n\t\t/**\r\n\t\t * @public\r\n\t\t * selection type\r\n\t\t */\r\n\t\tthis._options.selectionType = getOptionValue(options.selectionType, null);\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * observable handler\r\n\t\t */\r\n\t\tthis._observable = new Observable([\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when mouse is over a selection\r\n\t\t\t * @param {int} selectionIndex\r\n\t\t\t */\r\n\t\t\t\"selectionOver\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when selection is toggled\r\n\t\t\t * @param {int} selectionIndex\r\n\t\t\t * @param {bool} enabled\r\n\t\t\t */\r\n\t\t\t\"toggleSelection\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when selection is toggled\r\n\t\t\t * @param {int} selectionIndex\r\n\t\t\t * @param {bool} enabled\r\n\t\t\t */\r\n\t\t\t\"selectionChanged\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when user clicks on a handle\r\n\t\t\t * @param {int} handleIndex\r\n\t\t\t * @param {Number} handleValue\r\n\t\t\t */\r\n\t\t\t\"handleClick\"\r\n\t\t]);\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * histogramRenderer\r\n\t\t */\r\n\t\tthis._histogramRenderer = new HistogramRenderer(this._options);\r\n\r\n\t\tthis._histogramRenderer.on(\"selectionOver\", selectionIndex=>{\r\n\t\t\tthis._observable.fire(\"selectionOver\", selectionIndex);\r\n\t\t})\r\n\r\n\t\tthis._histogramRenderer.on(\"toggleSelection\", (selectionIndex, enabled)=>{\r\n\t\t\tthis._observable.fire(\"toggleSelection\", selectionIndex, enabled);\r\n\t\t})\r\n\r\n\t\tthis._histogramRenderer.on(\"selectionChanged\", (selection)=>{\r\n\t\t\tthis._observable.fire(\"selectionChanged\", selection);\r\n\t\t})\r\n\r\n\t\tthis._histogramRenderer.on(\"handleClick\", (handleIndex, handleValue)=>{\r\n\t\t\tthis._observable.fire(\"handleClick\", handleIndex, handleValue);\r\n\t\t});\r\n\t\t\r\n\t\tthis._selectionFactory = new HistogramSelectionFactory(this._options);\r\n\t}\r\n\r\n\t/**\r\n\t * Bind widget event\r\n\t * @param {String} event event name\r\n\t * @param {Function} handler event handler\r\n\t * @returns {Histogram} returns this widget instance\r\n\t */\r\n\ton(eventName, handler) {\r\n\t\tthis._observable.on(eventName, handler);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Unbind widget event\r\n\t * @param {String} event event name\r\n\t * @param {Function} [handler] event handler\r\n\t * @returns {Histogram} returns this widget instance\r\n\t */\r\n\toff(eventName, handler) {\r\n\t\tthis._observable.off(eventName, handler);\r\n\t\treturn this;\r\n\t}\t\r\n\r\n\t/**\r\n\t * Destroys widget\r\n\t * @returns {Histogram} returns this widget instance\r\n\t */\r\n\tdestroy() {\r\n\t\tthis._observable.destroy();\r\n\t\tthis._histogramRenderer.destroy();\r\n\t\tthis._options = null;\r\n\r\n\t\treturn this;\r\n\t}\t\r\n\r\n\t/**\r\n\t * Render logic of this widget\r\n\t * @param {String|DOMElement} selector selector or DOM element \r\n\t * @returns {Histogram} returns this widget instance\r\n\t */\r\n\trender(selector) {\r\n\t\tthis._histogramRenderer.render(selector);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets widget data\r\n\t * @param {Array} data\r\n\t * @param {Array} selection\r\n\t * @param {Object} set data options\r\n\t * @returns {Histogram} returns this widget instance \r\n\t */\r\n\tsetData(data, selection, options) {\r\n\t\tif (!this._histogramRenderer.isRendered()) {\r\n\t\t\tthrow \"Can't call setData() when widget is not rendered, please call .render() first.\"\r\n\t\t}\r\n\r\n\t\tvar histogramData = this._histogramData = new HistogramData(data, this._options);\r\n\t\tvar histogramSelection = this._histogramSelection = this._selectionFactory.getHistogramSelection(selection, histogramData);\r\n\r\n\t\tthis._options.selection = histogramSelection.getSelection();\r\n\t\tthis._selection = selection;\r\n\r\n\t\tif (!this._options.format) {\r\n\t\t\tthis._options.format = (value => String(value));\r\n\t\t} else if (typeof this._options.format == \"string\"){\r\n\t\t\tthis._options.format = d3.format(this._options.format);\r\n\t\t}\r\n\r\n\t\tthis._histogramRenderer.refresh(histogramData, histogramSelection, options);\r\n\r\n\t\treturn this;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @public\r\n\t * Sets selection type\r\n\t * @param {String} selectionType\r\n\t * @returns {Histogram} returns this widget instance \r\n\t */\r\n\tsetSelectionType(selectionType){\r\n\t\tthis._options.selectionType = selectionType;\r\n\t\tthis.setSelection(this._selection);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Shows selection labels\r\n\t */\r\n\tshowSelectionLabels(){\r\n\t\tthis._histogramRenderer.showSelectionLabels();\r\n\t}\r\n\r\n\t/**\r\n\t * Hides selection labels\r\n\t */\r\n\thideSelectionLabels(){\r\n\t\tthis._histogramRenderer.hideSelectionLabels();\r\n\t}\r\n\t\r\n\t/**\r\n\t * @public\r\n\t * Sets selection\r\n\t * @param {Array} selection\r\n\t * @param {Object} options\r\n\t * @returns {Histogram} returns this widget instance \r\n\t */\r\n\tsetSelection(selection, options) {\r\n\t\tif (!this._histogramRenderer.isRendered()) {\r\n\t\t\tthrow \"Can't call setData() when widget is not rendered, please call .render() first.\"\r\n\t\t}\r\n\r\n\t\tif (!this._histogramData) {\r\n\t\t\tthrow \"Can't call setSelection() when no data is available.\"\r\n\t\t}\r\n\r\n\t\tvar histogramSelection = this._histogramSelection = this._selectionFactory.getHistogramSelection(selection, this._histogramData);\r\n\t\tthis._options.selection = histogramSelection.getSelection();\r\n\t\tthis._selection = selection;\r\n\t\tthis._histogramRenderer.refresh(this._histogramData, this._histogramSelection, options);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\nHistogram.SelectionTypes = SelectionTypes;\r\nexport default Histogram;\r\n","/**\r\n * @class\r\n * Observable class, handles binding and firing events\r\n * @param {Array} events list of events for this observable\r\n */\r\nexport default class Observable {\r\n    /**\r\n     * @param {Array} events\r\n     */\r\n    constructor(events = []) {\r\n        // create a map of handlers where each event has an array of bound handlers\r\n        this._handlers = events.reduce((acc, cur)=>{\r\n            acc[cur] = [];\r\n            return acc;\r\n        },{});\r\n    }\r\n\r\n\t/**\r\n\t * @public\r\n\t * Bind event\r\n\t * @param {String} event event name\r\n\t * @param {Function} handler event handler\r\n\t */\r\n    on(event, handler) {\r\n        if (!(event in this._handlers)) throw \"No such event: \" + event;\r\n\t\tthis._handlers[event].push(handler);\r\n\t\treturn this;\r\n    }\r\n\r\n\t/**\r\n\t * @public\r\n\t * Unbind event\r\n\t * @param {String} event event name\r\n\t * @param {Function} [handler] event handler, optional\r\n\t */\r\n    off(event, handler) {\r\n        if (!(event in this._handlers)) throw \"No such event: \" + event;\r\n\t\tif (!handler) {\r\n\t\t\tthis._handlers[event] = [];\r\n\t\t} else {\r\n\t\t\tvar handlers = this._handlers[event];\r\n\t\t\tvar index = handlers.indexOf(handler);\r\n\t\t\tif (index != -1){\r\n\t\t\t\thandlers.splice(index, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n    }\r\n\r\n\t/**\r\n\t * @public\r\n\t * Fire widget event\r\n\t * @param {String} event event name\r\n\t * @param {*} ...args event arguments\r\n\t */\r\n\tfire(event, ...args) {\r\n\t\tif (!(event in this._handlers)) throw \"No such event: \" + event;\r\n\t\tvar handlers = this._handlers[event];\r\n\t\tfor (var i = 0; i < handlers.length; i++) {\r\n\t\t\thandlers[i].apply(this, args);\r\n\t\t}\r\n\t\treturn this;\r\n    }\r\n\r\n\t/**\r\n\t * @public\r\n\t * Destorys this observable, removes events and so on \r\n\t */\r\n\tdestroy() {\r\n\t\tthis._handlers = null;\r\n\t\treturn this;\r\n    }\r\n\t\r\n}","/**\r\n * @public\r\n * Default widget width\r\n */\r\nexport const WIDTH = 360;\r\n\r\n/**\r\n * @public\r\n * Default widget height\r\n */\r\nexport const HEIGHT = 150;\r\n\r\n/**\r\n * @public\r\n * Default widget margin\r\n */\r\nexport const MARGIN = {\r\n    top:0,\r\n    left:5,\r\n    right:5,\r\n    bottom:15\r\n};\r\n\r\n/**\r\n * Default label margin from x axis\r\n */\r\nexport const LABEL_MARGIN = 7;\r\n\r\n/**\r\n * @public\r\n * Default inactive bar color\r\n */\r\nexport const INACTIVE_BAR_COLOR = \"#f0f0f0\";\r\n\r\n/**\r\n * @public\r\n * Default inactive bar opacity\r\n */\r\nexport const INACTIVE_BAR_OPACITY = 1;\r\n\r\n/**\r\n * @public\r\n * Default over bar color\r\n */\r\nexport const OVER_SELECTION_COLOR = \"#ffea00\";\r\n\r\n/**\r\n * @public\r\n * Default over selection opacity\r\n */\r\nexport const OVER_SELECTION_OPACITY = 1;\r\n\r\n/**\r\n * @public\r\n * Default over bar color\r\n */\r\nexport const SELECTION_COLOR = \"#49ace2\";\r\n\r\n/**\r\n * @public\r\n * Enable selection toggle\r\n */\r\nexport const ENABLE_SELECTION_TOGGLE = true;\r\n\r\n/**\r\n * @public\r\n * Default font size\r\n */\r\nexport const FONT_SIZE = 11;\r\n\r\n/**\r\n * @public\r\n * Default colors \r\n */\r\nexport const DEFAULT_COLORS = [\"#e6f3fb\", \"#cbe7f6\", \"#b1dbf2\", \"#98cfee\", \"#7ec4ea\"];\r\n\r\n/**\r\n * @public\r\n * Default width of active handle area\r\n */\r\nexport const ACTIVE_HANDLE_AREA_WIDTH = 4;","import * as d3 from \"d3\";\n\n/**\n * @class\n * HistogramData representing data for the histogram view\n */\nexport default class HistogramData {\n\t/**\n\t * @param {data} data\n\t * @param {Object} options\n\t */\n\tconstructor(data, options) {\n\t\tthis._histogramData = this._loadHistogramData(data, options.width);\n\t\tthis._minMax = this._calculateMinMax(this._histogramData);\n\t\tthis._options = options;\n\t}\n\n\t/**\n\t * @public\n\t * Returns min max of history data\n\t * @returns {Object} minMax\n\t * @returns {Number} minMax.min\n\t * @returns {Number} minMax.max\n\t */\n\tgetMinMax() {\n\t\treturn this._minMax;\n\t}\n\n\t/**\n\t * @public\n\t * Returns histogram data\n\t * @returns {Array} histogram data\n\t */\n\tgetData() {\n\t\treturn this._histogramData;\n\t}\n\n\t/**\n\t* @private\n\t* Returns min max values for given histogramData\n\t* @param {Array} histogramData\n\t* @returns {Object} minMax.min\n\t* @returns {Object} minMax.max\n\t*/\n\t_calculateMinMax(histogramData) {\n\t\tvar min = d3.min(histogramData, function (d) { return d.value; });\n\t\tvar max = d3.max(histogramData, function (d) { return d.value; });\n\n\t\treturn {\n\t\t\tmin: min,\n\t\t\tmax: max\n\t\t}\n\t}\n\n\t/**\n\t * @public\n\t* Returns value ratio between bars and data\n\t* @return {Number} value ratio \n\t*/\n\tgetValueRatio() {\n\t\tvar range = this._minMax.max - this._minMax.min;\n\t\treturn range / this._options.width;\n\t}\n\n\t/**\n\t * @public\n\t * Returns data value from given position \n\t * @param {Number} position\n\t */\n\tpositionToValue(position) {\n\t\tvar minMax = this.getMinMax();\n\t\t// return min if position is 0\n\t\tif (position === 0){\n\t\t\treturn minMax.min;\n\t\t}\n\n\t\t// return max if position is at the end\n\t\tif (position === this._options.width){\n\t\t\treturn minMax.max;\n\t\t}\n\n\t\t// else calculate based on value ratio and min/max\n\t\tvar valueRatio = this.getValueRatio();\n\t\treturn position * valueRatio + minMax.min;\n\t}\n\n\t/**\n\t * @public\n\t * Returns position from given data value \n\t * @param {Number} value\n\t */\n\tvalueToPosition(value) {\n\t\tvar valueRatio = this.getValueRatio();\n\t\tvar minMax = this.getMinMax();\n\t\treturn Math.round(value / valueRatio - minMax.min / valueRatio);\n\t}\n\n\t/** \n\t* @private\n\t* @param {Array} buckets\n\t* @param {int} numOfBarsPerBucket - number of bars per column\\\n\t* @returns {Array} data from given buckets \n\t*/\n\t_loadHistogramData(data, width) {\n\t\tvar histogramData = [];\n\t\t// calculate number of bars per bucket excluding last pixel for max value\n\t\tvar numOfBarsPerBucket = (width-1) / data.length;\n\n\t\tdata.forEach((bucket, i) => {\n\t\t\tvar step = (bucket.max - bucket.min) / numOfBarsPerBucket;\n\t\t\td3.range(bucket.min, bucket.max, step).forEach((value) => {\n\t\t\t\thistogramData.push({\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tvolume: bucket.content[0].frequency\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// adding max value pixel as each non-last bucket ends one pixel before next bucket starts\n\t\t\tif (i == data.length-1){\n\t\t\t\thistogramData.push({\n\t\t\t\t\tvalue: bucket.max,\n\t\t\t\t\tvolume: bucket.content[0].frequency\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn histogramData;\n\t}\n}","import * as d3 from \"d3\";\r\nimport style from \"../Histogram.css\";\r\nimport * as Defaults from \"../HistogramDefaults\";\r\nimport Observable from \"../utils/Observable\";\r\n\r\n/**\r\n * Gradient index shared for all instances\r\n */\r\nvar gradientIndex = 0;\r\n\r\n/**\r\n * @class\r\n * HistogramHandle representing control handle for histogram\r\n */\r\nexport default class HistogramHandle {\r\n\t/**\r\n\t * @param {D3Selection} groupEl\r\n\t * @param {Number} value\r\n\t * @param {Number} index\r\n\t * @param {HistoryData} histogramData\r\n\t * @param {Object} options\r\n\t */\r\n\tconstructor(groupEl, value, index, histogramData, options) {\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * observable handler\r\n\t\t */\r\n\t\tthis._observable = new Observable([\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when mouse is over a selection\r\n\t\t\t * @param {int} selectionIndex\r\n\t\t\t */\r\n\t\t\t\"drag\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when drag on handle starts\r\n\t\t\t * @param {HistogramHandle} handle\r\n\t\t\t */\r\n\t\t\t\"startDrag\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when drag on handle ends\r\n\t\t\t * @param {HistogramHandle} handle\r\n\t\t\t */\r\n\t\t\t\"endDrag\"\r\n\t\t]);\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * handle element\r\n\t\t */\r\n\t\tthis._handleEl = null;\r\n\t\t\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * handle line element\r\n\t\t */\r\n\t\tthis._handleLineEl = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * handle circle element\r\n\t\t */\r\n\t\tthis._handleCircleEl = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * handle mask element\r\n\t\t */\r\n\t\tthis._handleMaskEl = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * handle mask gradient element\r\n\t\t */\r\n\t\tthis._handleMaskGradientEl = null;\t\t\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * handle label element\r\n\t\t */\r\n\t\tthis._handleLabelEl = null;\t\t\r\n\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * True if handle is over\r\n\t\t */\r\n\t\tthis._isOver = false;\r\n\t\t\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * Main group element\r\n\t\t */\t\t\r\n\t\tthis._groupEl = groupEl;\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * handle index\r\n\t\t */\t\t\r\n\t\tthis._index = index;\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * handle value\r\n\t\t */\t\t\r\n\t\tthis._value = value;\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * initial handle value\r\n\t\t */\t\t\r\n\t\tthis._initialValue = new Number(value);\t\t\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * handle position\r\n\t\t */\t\t\r\n\t\tthis._position = histogramData.valueToPosition(value);\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * initial handle position\r\n\t\t */\t\t\r\n\t\tthis._initialPosition = new Number(this._position);\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * bar options\r\n\t\t */\t\t\r\n\t\tthis._options = options;\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * histogram data\r\n\t\t */\t\t\r\n\t\tthis._histogramData = histogramData;\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * Cache for storing label size, enhances performance when animating\r\n\t\t */\t\t\r\n\t\tthis._labelSizeCache = {};\r\n\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * elements\r\n\t\t */\t\t\r\n\t\tthis._elements = [];\t\t\r\n\t\t\r\n\t\tthis._renderHandle();\r\n\t}\r\n\r\n\t/**\r\n\t * @public\r\n\t * Destroys this handle\r\n\t */\r\n\tdestroy(){\r\n\t\tthis._elements.forEach(element=>element.remove());\r\n\t\tthis._elements = [];\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t   * Renders drag handle\r\n\t   */\r\n\t_renderHandle() {\r\n\t\tthis._elements = [\r\n\t\t\tthis._createHandleElement(),\r\n\t\t\tthis._createHandleLineElement(),\r\n\t\t\tthis._createHandleCircleElement(),\r\n\t\t\tthis._createDragMaskElement(),\r\n\t\t\tthis._createMaskGradientElement(),\r\n\t\t\tthis._createDragLabelElement()\r\n\t\t];\r\n\r\n\t\tthis._handleHoverState();\r\n\t\tthis._handleDrag();\r\n\t}\t\r\n\r\n\thide(){\r\n\t\tthis._elements.forEach(element=>element.attr(\"visibility\", \"hidden\"));\r\n\t}\r\n\r\n\t/**\r\n\t * @public\r\n\t * Bind handle event\r\n\t * @param {String} event event name\r\n\t * @param {Function} handler event handler\r\n\t * @returns {HistogramHandle} returns this handle instance\r\n\t */\r\n\ton(eventName, handler) {\r\n\t\tthis._observable.on(eventName, handler);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * @public\r\n\t * Returns X position of this handle\r\n\t * @returns {Number} X position handle\r\n\t */\r\n\tgetXPosition() {\r\n\t\treturn parseInt(this._handleEl.attr(\"x\"))+Defaults.ACTIVE_HANDLE_AREA_WIDTH/2;\r\n\t}\r\n\r\n\t/**\r\n\t * @public\r\n\t * Sets hover state\r\n\t */\r\n\tsetHoverState(){\r\n\t\tthis._handleLineEl.attr(\"fill-opacity\", 1);\r\n\t\tthis._handleLabelEl.attr(\"fill-opacity\", 1);\r\n\t\tthis._handleMaskEl.attr(\"display\", \"block\");\r\n\t\tthis._handleCircleEl.attr(\"stroke-width\", 3);\r\n\t\tthis._updateLabelPosition(this._position);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @public \r\n\t * @returns {SVGRect} \r\n\t * Returns drag label box for this handle\r\n\t */\r\n\tgetLabelBox(){\r\n\t\treturn this._handleLabelEl.node().getBBox();\r\n\t}\r\n\r\n\t/**\r\n\t * @public \r\n\t * Shifts handle label by given offset so it can handle label position conflicts\r\n\t */\r\n\tsetLabelOffset(offset){\r\n\t\tthis._handleLabelEl.attr(\"transform\", \"translate(\"+offset+\", 0)\");\r\n\t\tthis._handleMaskEl.attr(\"transform\", \"translate(\"+offset+\", 0)\");\r\n\t\tthis._updateLabelPosition(this._position);\r\n\t}\r\n\r\n\t/**\r\n\t * @public \r\n\t * Sets handle position\r\n\t */\r\n\tsetHandleXPosition(position){\r\n\t\tthis._handleCircleEl.attr(\"transform\", \"translate(\"+position+\", \"+this._options.height+\")\")\r\n\t\treturn this;\r\n\t}\r\n\r\n\tsetLabelText(text){\r\n\t\tthis._handleLabelEl.text(text);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tshowLabel(){\r\n\t\tthis._handleLabelEl.attr(\"fill-opacity\", 1);\r\n\t\tthis._handleMaskEl.attr(\"display\", \"block\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\thideLabel(){\r\n\t\tthis._handleLabelEl.attr(\"fill-opacity\", 0);\r\n\t\tthis._handleMaskEl.attr(\"display\", \"none\");\r\n\t\treturn this;\r\n\t}\t\r\n\r\n\tsetLabelPosition(position){\r\n\t\tthis.setLabelOffset(0);\r\n\t\tthis._updateLabelPosition(position);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * @public\r\n\t * Unsets hover state\r\n\t */\r\n\tunsetHoverState(){\r\n\t\tthis._handleLineEl.attr(\"fill-opacity\", 0);\r\n\t\tthis._handleLabelEl.attr(\"fill-opacity\", 0);\r\n\t\tthis._handleMaskEl.attr(\"display\", \"none\");\r\n\t\tthis._handleCircleEl.attr(\"stroke-width\", 1);\r\n\t\tthis._handleLabelEl.attr(\"transform\", \"translate(0, 0)\")\r\n\t\tthis._handleMaskEl.attr(\"transform\", \"translate(0, 0)\")\r\n\t}\r\n\r\n\t/**\r\n\t * @public\r\n\t * Enables this handle \r\n\t */\r\n\tenable(){\r\n\t\tthis._elements.forEach(element => element.attr(\"pointer-events\", \"all\"));\r\n\t}\r\n\r\n\t/**\r\n\t * @public\r\n\t * Disables this handle \r\n\t */\r\n\tdisable(){\r\n\t\tthis._elements.forEach(element => element.attr(\"pointer-events\", \"none\"));\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * Handle hover state\r\n\t */\r\n\t_handleHoverState(){\r\n\t\t// line hover effect\r\n\t\tthis._handleEl.on(\"mouseover\", () => {\r\n\t\t\tthis._isOver = true;\r\n\t\t\tthis.setHoverState();\r\n\t\t})\r\n\t\tthis._handleEl.on(\"mouseout\", () => {\r\n\t\t\tthis._isOver = false;\r\n\t\t\tthis.unsetHoverState();\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * handles what happens when drag starts\r\n\t */\r\n\t_onStartDrag(){\r\n\t\tthis._groupEl.classed(style[\"dragging\"], true);\r\n\t\tthis._observable.fire(\"startDrag\", this);\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * handles what happens on drag\r\n\t */\r\n\t_onDrag(){\r\n\t\tvar width = this._options.width;\r\n\t\tvar height = this._options.height;\r\n\t\tvar xpos = Math.round(Math.max(Math.min(d3.event.x, width), 0));\r\n\r\n\t\tthis._handleEl.attr(\"x\", xpos - Defaults.ACTIVE_HANDLE_AREA_WIDTH/2);\r\n\t\tthis._handleLineEl.attr(\"x\", xpos - 2);\r\n\t\tthis._handleCircleEl.attr(\"transform\", \"translate(\" + xpos + \",\" + height + \")\");\r\n\t\tthis._handleEl.attr(\"data-handle-value\", this._histogramData.positionToValue(xpos))\r\n\r\n\t\tthis.setHoverState();\r\n\r\n\t\tthis._position = xpos;\r\n\r\n\t\t// prevent recalculating value for the same position\r\n\t\tif (parseInt(this._position) !== parseInt(this._initialPosition)){\r\n\t\t\tthis._value = this._histogramData.positionToValue(xpos);\r\n\t\t} else {\r\n\t\t\tthis._value = this._initialValue;\r\n\t\t}\r\n\r\n\t\tthis._handleLabelEl.text(this._getLabelText())\r\n\r\n\t\tthis._updateLabelPosition(xpos);\r\n\t\tthis._observable.fire(\"drag\");\t\t\r\n\t}\r\n\r\n\t_getLabelText() {\r\n\t\treturn this._options.format(this._value);\r\n\t}\r\n\t/**\r\n\t * @private\r\n\t * handles what happens when drag ends\r\n\t */\r\n\t_onEndDrag(){\r\n\t\tthis._groupEl.classed(style[\"dragging\"], false);\r\n\t\tif (!this._isOver) {\r\n\t\t\tthis.unsetHoverState();\r\n\t\t}\r\n\r\n\t\tthis._observable.fire(\"endDrag\", this);\t\t\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * Handles handle drag \r\n\t */\r\n\t_handleDrag(){\r\n\t\tthis._handleEl.call(d3.drag()\r\n\t\t\t.on(\"drag\", this._onDrag.bind(this))\r\n\t\t\t.on(\"start\", this._onStartDrag.bind(this))\r\n\t\t\t.on(\"end\", this._onEndDrag.bind(this)));\r\n\t}\r\n\t/**\r\n\t * @private\r\n\t * Return computed or stored label length\r\n\t * @param {SVGElement}\r\n\t * @param {Number} length \r\n\t */\r\n\t_getComputedLabelTextLength(label){\r\n\t\tvar content = label.innerHTML;\r\n\t\tthis._labelSizeCache[content] = this._labelSizeCache[content] || label.getComputedTextLength();\r\n\t\treturn this._labelSizeCache[content];\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * Updates label position\r\n\t * @param {Number} position \r\n\t */\r\n\t_updateLabelPosition(position) {\r\n\t\tvar label = this._handleLabelEl.node();\r\n\t\tvar maskPadding = this._options.fontSize;\t\t\r\n\r\n\t\t// we need to calculate text length so we can create mask and center text\r\n\t\tvar textLength = this._getComputedLabelTextLength(label);\r\n\t\tvar maskWidth = textLength + maskPadding * 2;\r\n\t\tvar xPosition = position - textLength / 2;\r\n\r\n\t\t// handle when dragging towards left side\r\n\t\tif (xPosition < 0) {\r\n\t\t\txPosition = 0;\r\n\t\t}\r\n\r\n\t\t// handle when dragging towards right side\r\n\t\tif (xPosition + textLength > this._options.width) {\r\n\t\t\txPosition = this._options.width  - textLength;\r\n\t\t\tthis._handleLabelEl.attr(\"x\", this._options.width);\r\n\t\t\tthis._handleLabelEl.attr(\"text-anchor\", \"end\");\r\n\t\t} else {\r\n\t\t\tthis._handleLabelEl.attr(\"x\", xPosition);\r\n\t\t\tthis._handleLabelEl.attr(\"text-anchor\", \"start\");\r\n\t\t}\r\n\r\n\t\t// position mask\r\n\t\tthis._handleMaskEl.attr(\"x\", () => {\r\n\t\t\treturn parseInt(xPosition) - maskPadding;\r\n\t\t});\r\n\r\n\t\tthis._handleMaskGradientEl.attr(\"x1\", xPosition - maskPadding);\r\n\t\tthis._handleMaskGradientEl.attr(\"x2\", xPosition + maskWidth - maskPadding);\r\n\r\n\t\tthis._handleMaskEl.attr(\"width\", maskWidth);\r\n\t\tthis._handleMaskEl.attr(\"height\", this._options.fontSize);\r\n\t}\r\n\t\t\r\n\t/**\r\n\t * Creates mask gradient element\r\n\t * @param {Number} handleIndex \r\n\t */\r\n\t_createMaskGradientElement(){\r\n\t\tthis._handleMaskGradientEl = this._groupEl.append(\"linearGradient\")\r\n\t\t\t.attr(\"id\", \"brush-mask-gradient-\" + gradientIndex++)\r\n\t\t\t.attr(\"gradientUnits\", \"userSpaceOnUse\")\r\n\t\t\t.attr(\"y1\", 0).attr(\"x1\", 50)\r\n\t\t\t.attr(\"y2\", 0).attr(\"x2\", 0);\r\n\r\n\t\tthis._handleMaskGradientEl.selectAll(\"stop\")\r\n\t\t\t.data([\r\n\t\t\t\t{ offset: \"0%\", color: \"rgba(255,255,255,0)\" },\r\n\t\t\t\t{ offset: \"20%\", color: \"rgba(255,255,255,1)\" },\r\n\t\t\t\t{ offset: \"80%\", color: \"rgba(255,255,255,1)\" },\r\n\t\t\t\t{ offset: \"100%\", color: \"rgba(255,255,255,0)\" }\r\n\t\t\t])\r\n\t\t\t.enter().append(\"stop\")\r\n\t\t\t.attr(\"offset\", function (d) { return d.offset; })\r\n\t\t\t.attr(\"stop-color\", function (d) { return d.color; });\r\n\r\n\t\treturn this._handleMaskGradientEl;\r\n\t}\r\n\r\n\t/**\r\n\t * @private \r\n\t * Renders main handle element \r\n\t * @returns {SVGElement}\r\n\t */\r\n\t_createHandleElement(){\r\n\t\tthis._handleEl = this._groupEl.append(\"rect\")\r\n\t\t\t.attr(\"class\", style[\"custom-handle\"])\r\n\t\t\t.attr(\"fill-opacity\", 0)\r\n\t\t\t.attr(\"data-handle-index\", this._index)\r\n\t\t\t.attr(\"data-handle-value\", this._value)\r\n\t\t\t.attr(\"cursor\", \"ew-resize\")\r\n\t\t\t.attr(\"width\", Defaults.ACTIVE_HANDLE_AREA_WIDTH)\r\n\t\t\t.attr(\"height\", this._options.height + 5)\r\n\t\t\t.attr(\"x\", this._position - Defaults.ACTIVE_HANDLE_AREA_WIDTH/2);\r\n\r\n\t\treturn this._handleEl;\r\n\t}\r\n\r\n\t/**\r\n\t * @private \r\n\t * Renders handle line element \r\n\t * @returns {SVGElement} \r\n\t */\r\n\t_createHandleLineElement(){\r\n\t\tthis._handleLineEl = this._groupEl.append(\"rect\")\r\n\t\t\t.attr(\"class\", style[\"custom-handle-line\"])\r\n\t\t\t.attr(\"width\", 4)\r\n\t\t\t.attr(\"height\", this._options.height)\r\n\t\t\t.attr(\"fill-opacity\", 0)\r\n\t\t\t.attr(\"x\", this._position - 2);\r\n\r\n\t\treturn this._handleLineEl;\r\n\t}\t\r\n\r\n\t/**\r\n\t * @private \r\n\t * Renders handle circle element \r\n\t * @returns {SVGElement} \r\n\t */\r\n\t_createHandleCircleElement(){\r\n\t\tthis._handleCircleEl = this._groupEl.append(\"circle\")\r\n\t\t\t.attr(\"class\", style[\"custom-handle-circle\"])\r\n\t\t\t.attr(\"transform\", \"translate(\" + this._position + \",\" + this._options.height + \")\")\r\n\t\t\t.attr(\"fill\", \"#ffffff\")\r\n\t\t\t.attr(\"fill-opacity\", 1)\r\n\t\t\t.attr(\"stroke\", \"#000\")\r\n\t\t\t.attr(\"stroke-width\", 1)\r\n\t\t\t.attr(\"cursor\", \"ew-resize\")\r\n\t\t\t.attr(\"r\", 3.5);\r\n\r\n\t\treturn this._handleCircleEl;\r\n\t}\t\t\r\n\r\n\t/**\r\n\t * @private \r\n\t * Renders drag mask element \r\n\t * @returns {SVGElement} \r\n\t */\r\n\t_createDragMaskElement(){\r\n\t\tthis._handleMaskEl = this._groupEl.append(\"rect\")\r\n\t\t\t.attr(\"class\", style[\"drag-label-mask\"])\r\n\t\t\t.attr(\"fill\", \"url(#brush-mask-gradient-\" + gradientIndex+\")\")\r\n\t\t\t.attr(\"y\", this._options.height + Defaults.LABEL_MARGIN)\r\n\t\t\t.attr(\"display\", \"none\");\t\t\t\r\n\r\n\t\treturn this._handleMaskEl;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @private \r\n\t * Renders handle label element \r\n\t * @returns {SVGElement}  \r\n\t */\r\n\t_createDragLabelElement(){\r\n\t\tvar format = this._options.format;\r\n\t\tvar height = this._options.height;\r\n\t\tthis._handleLabelEl = this._groupEl.append(\"text\")\r\n\t\t\t.attr(\"class\", style[\"drag-label\"])\r\n\t\t\t.attr(\"fill-opacity\", 0)\r\n\t\t\t.attr(\"font-size\", this._options.fontSize)\r\n\t\t\t.text(() => {\r\n\t\t\t\tvar formattedValue = format(this._initialValue);\r\n\t\t\t\treturn formattedValue;\r\n\t\t\t})\r\n\t\t\t.attr(\"y\", height + this._options.fontSize + Defaults.LABEL_MARGIN);\r\n\r\n\t\t\r\n\t\tthis._updateLabelPosition(this._position);\r\n\t\treturn this._handleLabelEl;\r\n\t}\r\n}","import style from \"../Histogram.css\";\r\nimport HistogramHandle from \"./HistogramHandle\";\r\nimport Observable from \"../utils/Observable\";\r\nimport * as PositionUtils from \"../utils/PositionUtils\"\r\nimport * as d3 from \"d3\";\r\n\r\n/**\r\n * @class\r\n * Histogram renderer class\r\n * @param {Object} options\r\n */\r\nexport default class HistogramSelectionRenderer {\r\n    constructor(options) {\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * Histogram options\r\n\t\t */\r\n\t\tthis._options = options;\r\n\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * Main group element of this widget\r\n\t\t */\r\n\t\tthis._groupEl = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * Bar data \r\n\t\t */\r\n\t\tthis._histogramData = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * history selection\r\n\t\t */\r\n\t\tthis._histogramSelection = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * index of over selection  \r\n\t\t */\r\n\t\tthis._overSelectionIndex = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * true if histogram has been rendered\r\n\t\t */\r\n\t\tthis._rendered = false;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * selection handles\r\n\t\t */\r\n\t\tthis._handles = [];\t\t\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * true if handle is dragged\r\n\t\t */\r\n\t\tthis._draggingHandle = false;\t\t\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * stores previous selection for animation\r\n\t\t */\r\n\t\tthis._prevSelection = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * true if histogram has been rendered\r\n\t\t */\r\n\t\tthis._rendered = false;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * true if animation is run\r\n\t\t */\r\n\t\tthis._animating = false;\r\n\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * observable handler\r\n\t\t */\r\n\t\tthis._observable = new Observable([\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when mouse is over a category\r\n\t\t\t * @param {int} selectionIndex\r\n\t\t\t */\r\n\t\t\t\"selectionOver\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when selection is toggled\r\n\t\t\t * @param {int} selectionIndex\r\n\t\t\t * @param {bool} enabled\r\n\t\t\t */\r\n\t\t\t\"toggleSelection\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when selection is changed\r\n\t\t\t * @param {int} selectionIndex\r\n\t\t\t * @param {bool} enabled\r\n\t\t\t */\r\n\t\t\t\"selectionChanged\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when user clicks on a handle\r\n\t\t\t * @param {int} handleIndex\r\n\t\t\t * @param {Number} handleValue\r\n\t\t\t */\r\n\t\t\t\"handleClick\"\r\n\t\t]);\t\t\r\n    }\r\n\r\n\t/**\r\n\t * @public\r\n\t * Returns whether histogram has been rendered or not\r\n\t * @returns {boolean} true if histogram has been rendered\r\n\t */\r\n\tisRendered(){\r\n\t\treturn this._rendered;\r\n\t}\r\n\r\n\t/**\r\n\t * @public\r\n\t * @param {DOMElement}  \r\n\t * @returns {HistogramSelectionRenderer} returns this widget instance\r\n\t */\r\n\trender(groupEl){\r\n\t\tthis._rendered = true;\r\n\t\tthis._groupEl = groupEl\r\n\r\n\t\treturn this;\r\n\t} \t\r\n\r\n\t/**\r\n\t * @public\r\n\t * Bind handle event\r\n\t * @param {String} event event name\r\n\t * @param {Function} handler event handler\r\n\t * @returns {HistogramHandle} returns this handle instance\r\n\t */\r\n\ton(eventName, handler) {\r\n\t\tthis._observable.on(eventName, handler);\r\n\t\treturn this;\r\n\t}\t \r\n\r\n\t/**\r\n\t * @private\r\n\t * Clears selection controls and data \r\n\t */\r\n\t_clear(){\r\n\t\tthis._destroyHandles();\r\n\t\tif (this._selectionBars){\r\n\t\t\tthis._selectionBars.remove();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * Destroys selection controls \r\n\t */\r\n\t_destroyHandles(){\r\n\t\tthis._handles.forEach(handle=>handle.destroy());\r\n\t\tthis._handles = [];\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * Handles click on handle\r\n\t * @param {Number} handleIndex\r\n\t * @param {Number} handleValue \r\n\t */\r\n\t_onHandleClick(handleIndex, handleValue){\r\n\t\t// call prompt handler if available\r\n\t\tif (this._options.promptHandler){\r\n\t\t\tthis._options.promptHandler(handleValue).then((promptResult)=>{\r\n\t\t\t\tpromptResult = parseFloat(promptResult);\r\n\t\t\t\t// must be within min max range\r\n\t\t\t\tvar minMax = this._histogramData.getMinMax();\r\n\t\t\t\tpromptResult = Math.min(minMax.max, promptResult);\r\n\t\t\t\tpromptResult = Math.max(minMax.min, promptResult);\r\n\r\n\t\t\t\tvar points = this._histogramSelection.getSelectionPoints();\r\n\t\t\t\tpoints[handleIndex] = {\r\n\t\t\t\t\tvalue:promptResult\r\n\t\t\t\t};\r\n\r\n\t\t\t\tvar positions = points\r\n\t\t\t\t\t.map(point=>this._histogramData.valueToPosition(point.value))\r\n\t\t\t\t\t.sort((p1,p2)=>p1-p2);\r\n\t\t\t\t\r\n\t\t\t\tthis._updateSelectionPositions(positions);\r\n\t\t\t\tthis._updateSelection();\r\n\r\n\t\t\t\t// TODO: update handles without destroying them\r\n\t\t\t\tthis._destroyHandles();\r\n\t\t\t\tthis._renderHandles();\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tthis._observable.fire(\"handleClick\", handleIndex, handleValue);\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * Toggles selection\r\n\t * @param {Number} selectionIndex \r\n\t */\r\n\t_toggleSelection(selectionIndex){\r\n\t\tvar selection = this._options.selection[selectionIndex];\r\n\t\tselection.disabled = !selection.disabled;\r\n\t\tvar enabled = !selection.disabled;\r\n\t\tthis._updateSelection();\r\n\t\tthis._observable.fire(\"toggleSelection\", selectionIndex, enabled);\r\n\t}\t\r\n\r\n\t/**\r\n\t * @private\r\n\t * Handles click on chart\r\n\t */\r\n\t_onClick(){\r\n\t\tvar target = d3.select(d3.event.target);\r\n\t\tvar selectionIndex = target.attr(\"data-selection-index\");\r\n\t\tvar handleIndex = target.attr(\"data-handle-index\");\r\n\r\n\t\tif (selectionIndex != null && this._histogramSelection.allowsToggle()){\r\n\t\t\tthis._toggleSelection(selectionIndex)\r\n\t\t} else if (handleIndex != null){\r\n\t\t\tthis._onHandleClick(handleIndex, target.attr(\"data-handle-value\"));\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * @private\r\n\t * Handles handle click \r\n\t */\r\n\t_handleClick(){\r\n\t\tthis._groupEl.on(\"click\", this._onClick.bind(this));\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * Refreshes histogram data \r\n\t * @param {HistogramData}\r\n\t * @param {HistogramSelection}\r\n\t * @param {Object} options\r\n\t */\r\n\trefresh(histogramData, histogramSelection, options){\r\n\t\tthis._animate = options && options.animate;\r\n\t\tif (this._animate && this._histogramSelection && this._histogramSelection.getSelection().length == histogramSelection.getSelection().length){\r\n\t\t\tthis._prevSelection = this._histogramSelection.getSelection();\r\n\t\t\tthis._prevHistogramData = this._histogramSelection.getSelection();\r\n\t\t}\r\n\r\n\t\tif (this._animate && this._histogramData){\r\n\t\t\tthis._prevHistogramData = this._histogramData;\r\n\t\t}\r\n\r\n\t\tthis._histogramData = histogramData;\r\n\t\tthis._histogramSelection = histogramSelection;\r\n\t\t\r\n\t\tthis._clear();\r\n\t\tthis._renderSelection();\r\n\t\tthis._updateSelection();\r\n\r\n\t\tthis._handleHoverState();\r\n\t\tthis._handleClick();\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * Updates selection controls on hover\r\n\t * @param {Number} selectionIndex \r\n\t */\r\n\t_updateSelectionControlsHoverState(selectionIndex){\r\n\t\t// get all handles sorted by X position\r\n\t\tvar handles = this._handles.slice().sort((h1,h2)=>{\r\n\t\t\treturn h1.getXPosition() - h2.getXPosition();\r\n\t\t});\r\n\r\n\t\t// unset hover state on all handles\r\n\t\thandles.forEach(handle=>handle.unsetHoverState());\r\n\r\n\t\t// selection is active, active both handles for active selection\r\n\t\tif (selectionIndex != null){\r\n\t\t\tvar handle1 = handles[selectionIndex];\r\n\t\t\tvar handle2 = handles[selectionIndex+1];\r\n\r\n\t\t\thandle1.setHoverState();\r\n\t\t\thandle2.setHoverState();\r\n\r\n\t\t\tvar labelOffsets = PositionUtils.getHandlePositionOffsets(handle1, handle2, this._options.fontSize, this._options.width);\r\n\r\n\t\t\thandle1.setLabelOffset(labelOffsets[0]);\r\n\t\t\thandle2.setLabelOffset(labelOffsets[1]);\r\n\t\t}\r\n\t}\t\r\n\r\n\t/**\r\n\t * \r\n\t * @private \r\n\t * Handles what happens when mouse is over selection\r\n\t * @param {String} type \r\n\t * @param {Number} i \r\n\t * @param {HTMLElement[]} array \r\n\t */\r\n\t_onSelectionMouseOver(d, i, nodes){\r\n\t\t// prevent selection when dragging handles\r\n\t\tif (this._draggingHandle){\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\td3.select(nodes[i]).attr(\"fill\", \"rgba(0,0,0,0.00)\")\r\n\t\tvar selectionIndex = parseInt(d3.select(d3.event.target).attr(\"data-selection-index\"));\r\n\t\tif (this._overSelectionIndex != selectionIndex){\r\n\t\t\tthis._overSelectionIndex = selectionIndex;\r\n\t\t\tthis._updateSelection();\r\n\t\t\tthis._updateSelectionControlsHoverState(selectionIndex);\r\n\t\t\tthis._observable.fire(\"selectionOver\", this._overSelectionIndex);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \r\n\t * @private \r\n\t * Handles what happens when mouse is out of selection\r\n\t * @param {String} type \r\n\t * @param {Number} i \r\n\t * @param {HTMLElement[]} array \r\n\t */\r\n\t_onSelectionMouseOut(d, i, nodes){\r\n\t\t// prevent selection when dragging handles\r\n\t\tif (this._draggingHandle){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\td3.select(nodes[i]).attr(\"fill\", \"rgba(0,0,0,0)\")\r\n\r\n\t\tthis._overSelectionIndex = null;\r\n\t\tthis._updateSelectionControlsHoverState(null);\r\n\t\tthis._updateSelection();\r\n\t\tthis._observable.fire(\"selectionOver\", this._overSelectionIndex);\r\n\t\t\r\n\t}\r\n\r\n\t/**\r\n\t * @private \r\n\t * Handles hover state\r\n\t */\r\n\t_handleHoverState(){\r\n\t\tvar g = this._groupEl;\r\n\t\tg.selectAll(\".\"+style.selectionbar).on(\"mouseout\", this._onSelectionMouseOut.bind(this));\r\n\t\tg.selectAll(\".\"+style.selectionbar).on(\"mouseover\", this._onSelectionMouseOver.bind(this));\r\n\t}\t\r\n\r\n\t/**\r\n\t * @private \r\n\t * Handles when handle is dragged\r\n\t */\r\n\t_onHandleDrag(){\r\n\t\tvar positions = this._handles.map(handle=>handle.getXPosition()).sort((p1, p2)=>{\r\n\t\t\treturn p1-p2;\r\n\t\t});\r\n\r\n\t\tthis._updateSelectionPositions(positions);\r\n\t}\r\n\r\n\t/**\r\n\t* @private\r\n\t* Updates selection with new positions\r\n\t* @param {Array} positions\r\n\t*/\r\n\t_updateSelectionPositions(positions){\r\n\t\tvar selection = this._histogramSelection.getSelection();\r\n\t\tpositions.forEach((p, index)=>{\r\n\t\t\tif (index>selection.length-1){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar position = {\r\n\t\t\t\tfrom:p,\r\n\t\t\t\tto:positions[index+1]\r\n\t\t\t};\r\n\r\n\t\t\t[\"from\", \"to\"].forEach(pos=>{\r\n\t\t\t\tif (selection[index][\"position\"][pos] !== position[pos]){\r\n\t\t\t\t\tselection[index][pos] = this._histogramData.positionToValue(position[pos]);\t\r\n\t\t\t\t\tselection[index][\"position\"][pos] = position[pos];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tthis._updateSelection();\r\n\t}\t\r\n\r\n\t/**\r\n\t* @private\r\n\t* Renders selection bars\r\n\t*/\r\n\t_renderSelection() {\r\n\t\tvar height = this._options.height;\r\n\t\tvar selection = this._histogramSelection.getSelection();\r\n\r\n\t\t// hover selection bars\r\n\t\tthis._selectionBars = this._groupEl.selectAll(\".\"+style.selectionbar)\r\n\t\t\t.data(selection)\r\n\t\t\t.enter().append(\"rect\")\r\n\t\t\t.attr(\"class\", style.selectionbar)\r\n\t\t\t.attr(\"y\", 0)\r\n\t\t\t.attr(\"fill\", \"rgba(0,0,0,0.00)\")\r\n\t\t\t.attr(\"height\", height);      \r\n\r\n\r\n\t\tthis._renderHandles();\r\n\t}\r\n\r\n\t/**\r\n\t* @private\r\n\t* Renders selection controls\r\n\t*/\r\n\t_renderHandles(){\r\n\t\t// render selection controls\r\n\t\tthis._handles = this._histogramSelection.getSelectionPoints().map((point, index)=>{\r\n\t\t\tvar value = point.value;\r\n\r\n\t\t\tvar handle = new HistogramHandle(this._groupEl, value, index, this._histogramData, this._options);\r\n\r\n\t\t\tif(point.hidden){\r\n\t\t\t\thandle.hide();\r\n\t\t\t}\r\n\r\n\t\t\thandle.on(\"drag\", ()=>{\r\n\t\t\t\tthis._onHandleDrag();\r\n\t\t\t}, this);\r\n\r\n\t\t\tvar startSelectionSnapshot;\r\n\r\n\t\t\t// disable other handles when draggin starts\r\n\t\t\thandle.on(\"startDrag\", ()=>{\r\n\t\t\t\tstartSelectionSnapshot = JSON.stringify(this._options.selection);\r\n\t\t\t\t\r\n\t\t\t\tthis._draggingHandle = true;\r\n\t\t\t\tthis._handles.forEach(handle=>handle.disable());\r\n\t\t\t\thandle.enable();\r\n\t\t\t}, this);\r\n\r\n\t\t\t// enable all handles when draggin starts\r\n\t\t\thandle.on(\"endDrag\", ()=>{\r\n\t\t\t\tthis._draggingHandle = false;\r\n\t\t\t\tthis._handles.forEach(handle=>handle.enable());\r\n\r\n\t\t\t\tif (JSON.stringify(this._options.selection) != startSelectionSnapshot){\r\n\t\t\t\t\tthis._observable.fire(\"selectionChanged\", this._histogramSelection.getOutputSelection());\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t\r\n\t\t\r\n\t\t\treturn handle;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t* @private\r\n\t* Returns bar color based on X position\r\n\r\n\t* @param {Number} barX\r\n\t* @param {Array} selection\r\n\t* @returns {Number} bar category index\r\n\t* @param {HistogramData} histogram data \r\n\t*/\r\n\t_getBarSelectionIndex(barX, selection, data){\r\n\t\tfor (var i=0;i<selection.length;i++){\r\n\t\t\tvar s = selection[i];\r\n\t\t\tvar isLast = i == selection.length-1;\r\n\t\t\tvar within = barX >= data.valueToPosition(s.from) && (barX < data.valueToPosition(s.to) || (isLast && barX <= data.valueToPosition(s.to)));\r\n\t\t\tif (within) return i;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\t\r\n\r\n\t/**\r\n\t * @private\r\n\t * Returns bar color for given bar position with given selection\r\n\t * @param {Number} barX \r\n\t * @param {Array} selection \r\n\t * @param {HistogramData} histogram data \r\n\t */\r\n\t_getBarColor (barX, selection, data){\r\n\t\tvar inactiveBarColor = this._options.inactiveBarColor;\r\n\t\tvar overSelectionColor = this._options.overSelectionColor;\r\n\t\t\r\n\t\tvar barSelectionIndex = this._getBarSelectionIndex(barX, selection, data);\r\n\t\tif (barSelectionIndex == null){\r\n\t\t\treturn inactiveBarColor;\r\n\t\t} else if (selection[barSelectionIndex].disabled){\r\n\t\t\treturn inactiveBarColor;\r\n\t\t} if (this._histogramSelection.allowsToggle() && this._overSelectionIndex == barSelectionIndex){\r\n\t\t\treturn overSelectionColor;\r\n\t\t} else {\r\n\t\t\treturn selection[barSelectionIndex].color || this._options.selectionColor;                    \r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * Returns bar color for given bar position with given selection\r\n\t * @param {Number} barX \r\n\t * @param {Array} selection \r\n\t * @param {HistogramData} histogram data \r\n\t */\r\n\t_getBarOpacity (barX, selection, data){\r\n\t\tvar defaultOpacity = 1;\r\n\r\n\t\tvar barSelectionIndex = this._getBarSelectionIndex(barX, selection, data);\r\n\t\tvar isOver = this._histogramSelection.allowsToggle() && this._overSelectionIndex == barSelectionIndex;\r\n\t\tvar isDisabled = barSelectionIndex != null && selection[barSelectionIndex].disabled;\r\n\r\n\t\tif (isOver){\r\n\t\t\treturn this._options.overSelectionOpacity;\r\n\t\t}\r\n\r\n\t\tif (isDisabled){\r\n\t\t\treturn this._options.inactiveBarOpacity;\r\n\t\t}\r\n\t\t\r\n\t\t// otherwise use set opacity if \r\n\t\tif (barSelectionIndex != null && selection[barSelectionIndex].opacity != null){\r\n\t\t\treturn selection[barSelectionIndex].opacity;\r\n\t\t} \r\n\r\n\t\treturn defaultOpacity;\r\n\t}\t\r\n\r\n\t/**\r\n\t * Runs onTransition as a transition between two selections\r\n\t * @param {Array} selection1 \r\n\t * @param {Array} selection2 \r\n\t * @param {Function} onTransition handler\r\n\t */\r\n\t_onSelectionTransition(selection1, selection2, data1, data2, onTransition, onComplete){\r\n\t\tselection1.forEach((s1,selectionIndex)=>{\r\n\t\t\tvar s2 = selection2[selectionIndex];\r\n\t\t\tvar width = this._options.width;\r\n\t\t\tif (selection1[selectionIndex]){\r\n\t\t\t\tvar transitions = [];\r\n\t\t\t\tvar frames = [];\r\n\r\n\t\t\t\ttransitions.push([Math.round(data1.valueToPosition(s1.from)), Math.round(data2.valueToPosition(s2.from))]);\r\n\t\t\t\ttransitions.push([Math.round(data1.valueToPosition(s1.to)), Math.round(data2.valueToPosition(s2.to))]);\r\n\r\n\t\t\t\t// make sure duration is calculated based on transitino length\r\n\t\t\t\tframes = [Math.abs((transitions[0][0] - transitions[0][1])/width), Math.abs((transitions[1][0] - transitions[1][1])/width)];\r\n\r\n\t\t\t\ttransitions.forEach((t, handleIndex)=>{\r\n\t\t\t\t\tvar duration = 0;\r\n\r\n\t\t\t\t\twhile(t[0] !== t[1]){\r\n\t\t\t\t\t\tsetTimeout(onTransition.bind(this, t[0], selectionIndex, handleIndex), duration);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tduration = duration+0.5/frames[handleIndex];\r\n\t\t\t\t\t\tt[0] = t[0]>t[1]?t[0]-1:t[0]+1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// call final complete fn only if duration is > 0, this prevents premature animation end\r\n\t\t\t\t\t// when one of the sides is in the same position\r\n\t\t\t\t\tif (duration>0){\r\n\t\t\t\t\t\tsetTimeout(function(p, si, hi){\r\n\t\t\t\t\t\t\tonTransition(p, si, hi)\r\n\t\t\t\t\t\t\tonComplete(p, si, hi);\r\n\t\t\t\t\t\t}.bind(this, t[1], selectionIndex, handleIndex), ++duration);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t* @private\r\n\t* Updates selection\r\n\t*/\r\n\t_updateSelection(){\r\n\t\tvar selection = this._histogramSelection.getSelection();\r\n\t\tvar bars = this._groupEl.selectAll(\".\"+style.bar);\r\n\r\n\t\t// fills bars with given selection\r\n\t\tvar fillBars = (s, data) => {\r\n\t\t\t// handle bar colors\r\n\t\t\tbars.attr(\"fill\", (d)=> {\r\n\t\t\t\tvar barX = this._histogramData.valueToPosition(d.value);\r\n\t\t\t\treturn this._getBarColor(barX, s, data);\r\n\t\t\t})\r\n\r\n\t\t\t// handle bar opacity\r\n\t\t\tbars.attr(\"fill-opacity\", (d)=> {\r\n\t\t\t\tvar barX = this._histogramData.valueToPosition(d.value);\r\n\t\t\t\treturn this._getBarOpacity(barX, s, data);\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\t// handle animation if previous selection is set\r\n\t\tif (this._animate && this._prevSelection){\r\n\t\t\tvar prevSelection = this._prevSelection;\r\n\t\t\tvar prevData = this._prevHistogramData;\r\n\t\t\t\r\n\t\t\t// set prev selection\r\n\t\t\tfillBars(prevSelection, this._prevHistogramData);\r\n\r\n\t\t\t// set handle positions to prev selection\r\n\t\t\tprevSelection.forEach((s, i)=>{\r\n\t\t\t\tvar p1 = this._prevHistogramData.valueToPosition(s.from);\r\n\t\t\t\tvar p2 = this._prevHistogramData.valueToPosition(s.to);\r\n\r\n\t\t\t\tthis._handles[i].setHandleXPosition(p1).setLabelPosition(p1);\r\n\t\t\t\tthis._handles[i+1].setHandleXPosition(p2).setLabelPosition(p2)\r\n\t\t\t});\r\n\r\n\t\t\tthis._animating = true;\r\n\t\t\t//fill bars on selection transition and move handles\r\n\t\t\tthis._onSelectionTransition(prevSelection, selection, prevData, this._histogramData, \r\n\t\t\t\t// on transition callback\r\n\t\t\t\t(p, selectionIndex, handleIndex)=>{\r\n\t\t\t\t\tvar bar = d3.select(bars.nodes()[p]);\r\n\t\t\t\t\tvar barColor = this._getBarColor(p, selection, this._histogramData);\r\n\t\t\t\t\tbar.attr(\"fill\", barColor);\r\n\r\n\t\t\t\t\t//var handleText = this._options.format(this._histogramData.positionToValue(p));\r\n\t\t\t\t\t// move handles\r\n\t\t\t\t\t[this._handles[selectionIndex], this._handles[selectionIndex+1]][handleIndex].setHandleXPosition(p).setLabelPosition(p)\r\n\r\n\t\t\t\t// on complete callback\t\t\r\n\t\t\t},()=>{\r\n\t\t\t\t\t// hide handles\r\n\t\t\t\t\t//[this._handles[selectionIndex], this._handles[selectionIndex+1]][handleIndex].hideLabel();\r\n\t\t\t\t\tfillBars(selection, this._histogramData)\r\n\t\t\t\t\tthis._animating = false;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t\tthis._prevSelection = null;\r\n\t\t\tthis._prevHistogramData = null;\r\n\t\t\r\n\t\t} else {\r\n\t\t\tfillBars(selection, this._histogramData)\r\n\t\t}\r\n\t\t\r\n\t\t// selection rects\r\n\t\tthis._groupEl.selectAll(\".\"+style.selectionbar)\r\n\t\t\t.data(selection)\r\n\t\t\t.attr(\"data-selection-index\", function(d,i){\r\n\t\t\t\treturn i;\r\n\t\t\t})\r\n\t\t\t.attr(\"x\", (d) => { \r\n\t\t\t\treturn this._histogramData.valueToPosition(d.from);\r\n\t\t\t})\r\n\t\t\t.attr(\"width\", (d) => {\r\n\t\t\t\treturn this._histogramData.valueToPosition(d.to) - this._histogramData.valueToPosition(d.from);\r\n\t\t\t})\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Shows selection labels\r\n\t */\r\n\tshowSelectionLabels(){\r\n\t\t// show label without calculating offsets when animating\r\n\t\tif (this._animating) {\r\n\t\t\treturn this._handles.forEach(handle=>handle.showLabel());\r\n\t\t}\r\n\r\n\t\tthis._histogramSelection.getSelection().forEach((s,i)=>{\r\n\t\t\tvar handle1 = this._handles[i];\r\n\t\t\tvar handle2 = this._handles[i+1];\r\n\r\n\t\t\tvar labelOffsets = PositionUtils.getHandlePositionOffsets(handle1, handle2, this._options.fontSize, this._options.width);\r\n\t\t\thandle1.setLabelOffset(labelOffsets[0]);\r\n\t\t\thandle2.setLabelOffset(labelOffsets[1]);\r\n\t\t});\r\n\t\t\r\n\t\tthis._handles.forEach(handle=>handle.showLabel());\r\n\t}\r\n\r\n\t/**\r\n\t * Hides selection labels\r\n\t */\r\n\thideSelectionLabels(){\r\n\t\tthis._handles.forEach(handle=>handle.hideLabel());\r\n\t}\t\t\r\n\r\n\t/**\r\n\t * @public\r\n\t * Destorys histogram UI  \r\n\t */\r\n\tdestroy() {\r\n\t\tthis._observable.destroy();\r\n\t\tthis._clear();\r\n\r\n\t\treturn this;\r\n    }\t\t\r\n}","import style from \"./Histogram.css\";\r\nimport HistogramSelectionRenderer from \"./selection/HistogramSelectionRenderer\";\r\nimport * as Defaults from \"./HistogramDefaults\";\r\nimport Observable from \"./utils/Observable\";\r\nimport * as d3 from \"d3\";\r\n\r\n/**\r\n * @class\r\n * Histogram renderer class\r\n * @param {Object} options\r\n */\r\nexport default class HistogramRenderer {\r\n    constructor(options) {\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * Histogram options\r\n\t\t */\r\n\t\tthis._options = options;\r\n\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * DOM container of this widget\r\n\t\t */\r\n\t\tthis._containerEl = null;\r\n\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * Main group element of this widget\r\n\t\t */\r\n\t\tthis._groupEl = null;\r\n\r\n\t\t/**\r\n\t\t * @private \r\n\t\t * Main SVG element of this widget\r\n\t\t */\r\n\t\tthis._svgEl = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * Bar data \r\n\t\t */\r\n\t\tthis._historyData = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * X axis\r\n\t\t */\r\n\t\tthis._xAxis = d3.scaleBand().range([0, options.width]);\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * Y axis\r\n\t\t */\r\n\t\tthis._yAxis = d3.scaleLinear().range([options.height, 0]);\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * true if histogram has been rendered\r\n\t\t */\r\n\t\tthis._rendered = false;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * stores previous data for animation\r\n\t\t */\r\n\t\tthis._prevData = null;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * selection renderer\r\n\t\t */\r\n\t\tthis._selectionRenderer = new HistogramSelectionRenderer(options);\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * True if labels are visible\r\n\t\t */\r\n\t\tthis._labelsVisible = false;\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * observable handler\r\n\t\t */\r\n\t\tthis._observable = new Observable([\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when mouse is over a category\r\n\t\t\t * @param {int} selectionIndex\r\n\t\t\t */\r\n\t\t\t\"selectionOver\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when selection is toggled\r\n\t\t\t * @param {int} selectionIndex\r\n\t\t\t * @param {bool} enabled\r\n\t\t\t */\r\n\t\t\t\"toggleSelection\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when selection is changed\r\n\t\t\t * @param {Array} selection\r\n\t\t\t */\r\n\t\t\t\"selectionChanged\",\r\n\t\t\t/**\r\n\t\t\t * @event \r\n\t\t\t * Fires when user clicks on a handle\r\n\t\t\t * @param {int} handleIndex\r\n\t\t\t * @param {Number} handleValue\r\n\t\t\t */\r\n\t\t\t\"handleClick\"\r\n\t\t]);\t\t\r\n\r\n\t\t// relay selection events\r\n\t\tthis._selectionRenderer.on(\"selectionOver\", (selectionIndex)=>{\r\n\t\t\tthis._observable.fire(\"selectionOver\", selectionIndex);\r\n\t\t});\r\n\r\n\t\tthis._selectionRenderer.on(\"toggleSelection\", (selectionIndex, enabled)=>{\r\n\t\t\tthis._observable.fire(\"toggleSelection\", selectionIndex, enabled);\r\n\t\t});\r\n\r\n\t\tthis._selectionRenderer.on(\"selectionChanged\", (selection)=>{\r\n\t\t\tthis._observable.fire(\"selectionChanged\", selection);\r\n\t\t});\r\n\r\n\t\tthis._selectionRenderer.on(\"handleClick\", (handleIndex, handleValue)=>{\r\n\t\t\tthis._observable.fire(\"handleClick\", handleIndex, handleValue);\r\n\t\t});\t\t\r\n    }\r\n\r\n\t/**\r\n\t * @public\r\n\t * Returns whether histogram has been rendered or not\r\n\t * @returns {boolean} true if histogram has been rendered\r\n\t */\r\n\tisRendered(){\r\n\t\treturn this._rendered;\r\n\t}\r\n\r\n\t/**\r\n\t * @public\r\n\t * Bind handle event\r\n\t * @param {String} event event name\r\n\t * @param {Function} handler event handler\r\n\t * @returns {HistogramHandle} returns this handle instance\r\n\t */\r\n\ton(eventName, handler) {\r\n\t\tthis._observable.on(eventName, handler);\r\n\t\treturn this;\r\n\t}\t\r\n\r\n\t/**\r\n\t * @public\r\n\t * Render logic of this widget\r\n\t * @param {String|DOMElement} selector selector or DOM element \r\n\t * @returns {Histogram} returns this widget instance\r\n\t */\r\n\trender(selector){\r\n\t\t// get container element using selector or given element\r\n\t\tvar ct = this._containerEl = d3.select(selector);\r\n\t\tvar width = this._options.width;\r\n\t\tvar height = this._options.height;\r\n\t\tvar margin = Defaults.MARGIN;\r\n\r\n\t\t// render SVG\r\n\t\tvar svg = this._svgEl = ct.append(\"svg\")\r\n\t\t\t.attr(\"width\", width + margin.left + margin.right)\r\n\t\t\t.attr(\"height\", height + margin.top + this._options.fontSize + margin.bottom);\r\n\r\n\t\t// render group element\r\n\t\tvar g = this._groupEl = this._svgEl.append(\"g\")\r\n\t\t\t.classed(style.inactive, true)\r\n\t\t\t.attr(\"transform\",\r\n\t\t\t\"translate(\" + margin.left + \",\" + margin.top + \")\");\r\n\r\n\t\t// handle hover over svg element\r\n\t\tsvg.on(\"mouseover.hover\", ()=>{\r\n\t\t\tg.classed(style.active, true)\r\n\t\t\tg.classed(style.inactive, false)\r\n\t\t})\r\n\r\n\t\tsvg.on(\"mouseout.hover\", ()=>{\r\n\t\t\tg.classed(style.inactive, true)\r\n\t\t\tg.classed(style.active, false)\r\n\t\t})\r\n\r\n\t\tthis._selectionRenderer.render(g);\r\n\r\n\t\tthis._rendered = true;\r\n\r\n\t\treturn this;\r\n\t} \r\n\r\n\t/**\r\n\t * @private\r\n\t * Clears selection controls and data \r\n\t */\r\n\t_clear(){\r\n\t\tthis._groupEl.node().innerHTML = \"\";\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * Refreshes histogram data \r\n\t * @param {HistogramData}\r\n\t * @param {HistogramSelection}\r\n\t * @param {Object} options\r\n\t */\r\n\trefresh(histogramData, histogramSelection, options){\r\n\t\tthis._animate = options && options.animate;\r\n\r\n\t\tthis._histogramData = histogramData;\t\t\r\n\t\tthis._clear();\r\n\r\n\t\tthis._xAxis.domain(histogramData.getData().map(function (d) {return d.value; }));\r\n\t\tthis._yAxis.domain([0, d3.max(histogramData.getData(), function (d) { return d.volume; })]);\r\n\r\n\t\tthis._renderXAxis();\t\t\r\n\t\tthis._renderDataBars();\r\n\r\n\t\tthis._prevData = histogramData.getData();\t\t\t\r\n\r\n\t\tthis._selectionRenderer.refresh(histogramData, histogramSelection, options);\t\r\n\r\n\t\tif (this._labelsVisible){\r\n\t\t\tthis.showSelectionLabels()\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Shows selection labels\r\n\t */\r\n\tshowSelectionLabels(){\r\n\t\tthis._selectionRenderer.showSelectionLabels();\r\n\t\t// hide axis labels when selection labels are visible\r\n\t\tthis._groupEl.selectAll(\".\"+style[\"x-axis\"]).attr(\"display\", \"none\");\r\n\t\tthis._labelsVisible = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Hides selection labels\r\n\t */\r\n\thideSelectionLabels(){\r\n\t\tthis._selectionRenderer.hideSelectionLabels();\r\n\t\t// show axis labels when selection labels are not visible\r\n\t\tthis._groupEl.selectAll(\".\"+style[\"x-axis\"]).attr(\"display\", \"block\");\t\t\r\n\t\tthis._labelsVisible = false;\r\n\t}\t\r\n\r\n\t/**\r\n\t * @private\r\n\t * Renders data bars\r\n\t*/\r\n\t_renderDataBars() { \r\n\t\tvar data = this._histogramData.getData();\r\n\t\t// var prevData = this._prevData;\r\n\t\tvar height = this._options.height;\r\n\r\n\t\tvar y = this._yAxis;\r\n\r\n\t\t// disable this for now as it's slow to animate all bars\r\n\t\t// animate from previous data if available\r\n\t\t// if (this._animate && prevData){\r\n\t\t// \tx.domain(prevData.map(function (d) {return d.value; }));\r\n\t\t// \ty.domain([0, d3.max(prevData, function (d) { return d.volume; })]);\r\n\r\n\t\t// \tthis._groupEl.selectAll(\".\"+style.bar)\r\n\t\t// \t\t.data(prevData)\r\n\t\t// \t\t.enter().append(\"rect\")\r\n\t\t// \t\t.attr(\"class\", style.bar)\r\n\t\t// \t\t.attr(\"x\", function (d) { return x(d.value); })\r\n\t\t// \t\t.attr(\"width\", x.bandwidth())\r\n\t\t// \t\t.attr(\"y\", function (d) { return Math.floor(y(d.volume)); })\r\n\t\t// \t\t.attr(\"height\", function (d) {return Math.ceil(height - y(d.volume)); })\r\n\r\n\t\t// \tx.domain(data.map(function (d) {return d.value; }));\r\n\t\t// \ty.domain([0, d3.max(data, function (d) { return d.volume; })]);\t\t\t\t\r\n\r\n\t\t// \tthis._groupEl.selectAll(\".\"+style.bar)\r\n\t\t// \t\t.data(data)\r\n\t\t// \t\t.transition()\r\n\t\t// \t\t.duration(250)\r\n\t\t// \t\t.attr(\"y\", function (d) { return Math.floor(y(d.volume)); })\r\n\t\t// \t\t.attr(\"height\", function (d) { return Math.ceil(height - y(d.volume)); })\r\n\t\t// } else {\r\n\t\t\t// append the rectangles for the bar chart\r\n\t\t\tthis._groupEl.selectAll(\".\"+style.bar)\r\n\t\t\t\t.data(data)\r\n\t\t\t\t.enter().append(\"rect\")\r\n\t\t\t\t.attr(\"class\", style.bar)\r\n\t\t\t\t.attr(\"x\", (d) => { return this._histogramData.valueToPosition(d.value); })\r\n\t\t\t\t.attr(\"width\", \"1\")\r\n\t\t\t\t.attr(\"y\", (d) => { return Math.floor(y(d.volume)); })\r\n\t\t\t\t.attr(\"height\", function (d) { return Math.ceil(height - y(d.volume)); })\r\n\t\t//}\r\n\t}\r\n\r\n\t/**\r\n\t* @private\r\n\t* Renders X axis \r\n\t*/        \r\n\t_renderXAxis(){\r\n\t\tvar minMax = this._histogramData.getMinMax();\r\n\t\tvar format = this._options.format;\r\n\t\tvar height = this._options.height + this._options.fontSize + Defaults.LABEL_MARGIN;\r\n\r\n\t\tthis._groupEl.selectAll(\".\"+style[\"x-axis\"])\r\n\t\t\t.data([minMax.min, minMax.max])\r\n\t\t\t.enter()\r\n\t\t\t.append(\"text\")\r\n\t\t\t.text((d)=>format(d))\r\n\t\t\t.attr(\"font-size\", this._options.fontSize)\r\n\t\t\t.attr(\"transform\", (d, i)=>{\r\n\t\t\t\treturn [\r\n\t\t\t\t\t\"translate(\"+0+\",\" + height + \")\",\r\n\t\t\t\t\t\"translate(\"+this._options.width+\",\" + height + \")\"\r\n\t\t\t\t][i]\r\n\t\t\t})\r\n\t\t\t.attr(\"text-anchor\", function(d, i){\r\n\t\t\t\treturn [\"start\", \"end\"][i];\r\n\t\t\t})\r\n\t\t\t.classed(style[\"x-axis\"], true)\r\n\t}\r\n\r\n\t/**\r\n\t * @public\r\n\t * Destorys histogram UI  \r\n\t */\r\n\tdestroy() {\r\n\t\tif (this._rendered){\r\n\t\t\tthis._containerEl.node().removeChild(this._svgEl.node());\r\n\t\t}\r\n\r\n\t\tthis._observable.destroy();\r\n\t\tthis._selectionRenderer.destroy();\r\n\r\n\t\treturn this;\r\n    }\t\r\n\t\r\n}","/**\n * @abstract\n * abstract HistogramSelection class\n */\nexport default class HistogramSelection {\n\tconstructor(histogramData, selection){\n\t\tthis._selection = selection.map(s=>{\n\t\t\treturn Object.assign(s, {\n\t\t\t\tposition:{\n\t\t\t\t\tfrom:histogramData.valueToPosition(s.from),\n\t\t\t\t\tto:histogramData.valueToPosition(s.to)\n\t\t\t\t}\n\t\t\t});\n\t\t});\n    }\n\n\t/**\n\t * @public\n\t * @implements HistogramSelection.getSelection()\n\t * Returns histogram selection\n\t */\n\tgetSelection(){\n\t\treturn this._selection;\n\t}\n\n\t/**\n\t * @public\n\t * @abstract\n\t * @returns {Array} histogram selection\n\t * Returns histogram selection \n\t */\n\tgetOutputSelection(){\n\t\tthrow \"HistogramSelection.getOutputSelection() has to be implemented\";\n\t}\n\n\t/**\n\t * @public \n\t * @abstract\n\t * @returns {String}\n\t * Returns histogram selection type\n\t */\n\tgetSelectionType(){\n\t\tthrow \"HistogramSelection.getSelectionType() has to be implemented\";\n\t}\n\n\t/**\n\t * @abstract\n\t * @public \n\t * @returns {Boolean}\n\t * Returns true if toogle is allowed\n\t */\n\tallowsToggle(){\n\t\tthrow \"HistogramSelection.allowsToogle() has to be implemented\";\n\t}\t\n\n\t/**\n\t * @public\n\t * @abstract \n\t * @returns {Array}\n\t * Returns histogram selection points\n\t */\n\tgetSelectionPoints(){\n\t\tthrow \"HistogramSelection.getSelection() has to be implemented\";\n\t}  \t\n}\n\nvar SelectionTypes = {\n\tMULTI:\"multi\",\n\tFILTER:\"filter\",\n\tINVERTED_FILTER:\"inverted-filter\"\n}\n\nexport {SelectionTypes} ","import HistogramSelection from \"./HistogramSelection\";\nimport {SelectionTypes} from \"./HistogramSelection\";\n\n/**\n * @class\n * MultipleHistogramSelection representing histogram selection that support multiple selections\n */\nexport default class MultipleHistogramSelection extends HistogramSelection{\n\t/**\n\t * @param {HistogramData} histogramData\n\t * @param {Array} selection\n\t */\n    constructor(histogramData, selection) {\n\t\tsuper(histogramData, selection);\n    }\n\n\t/**\n\t * @public\n\t * @implements HistogramSelection.getSelectionType()\n\t * Returns histogram selection\n\t */\n\tgetSelectionType(){\n\t\treturn SelectionTypes.MULTI;\n\t}\n\n\t/**\n\t * @public\n\t * @returns {Array} histogram selection\n\t * @implements HistogramSelection.getOutputSelection()\n\t * Returns histogram selection \n\t */\n\tgetOutputSelection(){\n\t\treturn this._selection;\n\t}\t\n\n\t/**\n\t * @public\n\t * @implements HistogramSelection.allowsToggle()\n\t * Returns true if selection allows toggle\n\t */\n\tallowsToggle(){\n\t\treturn true;\n\t}\n\n\t/**\n\t * @public \n\t * @implements HistogramSelection.getSelectionPoints()\n\t * Returns histogram selection points\n\t */\n\tgetSelectionPoints(){\n\t\tvar result = [];\n\t\tvar selection = this.getSelection();\n\t\tselection.forEach((s, index)=>{\n\t\t\tresult.push({\n\t\t\t\tvalue:s.from\n\t\t\t});\n\t\t\t\n\t\t\tif (index == selection.length-1){\n\t\t\t\tresult.push({\n\t\t\t\t\tvalue:s.to\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}  \t \t\n}","import MultipleHistogramSelectionImpl from \"./MultipleHistogramSelectionImpl\";\nimport * as Defaults from \"../HistogramDefaults\";\n\n/**\n * @class\n * DefaultHistogramSelectionImpl representing histogram selection\n */\nexport default class DefaultHistogramSelectionImpl extends MultipleHistogramSelectionImpl {\n\t/**\n\t * @param {HistogramData} histogramData\n\t * @param {Array} selection\n\t */\n    constructor(histogramData) {\n\t\tvar minMax = histogramData.getMinMax();\n\t\tvar colors = Defaults.DEFAULT_COLORS;\n\t\tvar start = minMax.min;\n\t\tvar step = (minMax.max - minMax.min) / colors.length;\n\t\tvar selection = colors.map(color=>{\n\t\t\tvar from = start;\n\t\t\tvar to = start + step;\n\t\t\tstart += step;\n\n\t\t\treturn {\n\t\t\t\tfrom:from, \n\t\t\t\tto:to,\n\t\t\t\tcolor:color\n\t\t\t}\n\t\t});\n\n\t\tsuper(histogramData, selection);\n    }\n}","import HistogramSelection from \"./HistogramSelection\";\nimport {SelectionTypes} from \"./HistogramSelection\";\n\n/**\n * @class\n * MultipleHistogramSelection representing histogram selection that support multiple selections\n */\nexport default class FilterHistogramSelectionImpl extends HistogramSelection{\n\t/**\n\t * @param {HistogramData} histogramData\n\t * @param {Array} selection\n\t */\n    constructor(histogramData, selection) {\n\t\tif (selection.length != 1){\n\t\t\tthrow \"Filter selection doesn't allow more than one selection\"\n\t\t}\n\t\tsuper(histogramData, selection);\n\t}\n\t/**\n\t * @public\n\t * @returns {Array} histogram selection\n\t * @implements HistogramSelection.getOutputSelection()\n\t * Returns histogram selection \n\t */\n\tgetOutputSelection(){\n\t\treturn this._selection;\n\t}\t\t\n\n\t/**\n\t * @public\n\t * @implements HistogramSelection.getSelectionType()\n\t * Returns histogram selection\n\t */\n\tgetSelectionType(){\n\t\treturn SelectionTypes.FILTER;\n\t}\t\n\n\t/**\n\t * @public\n\t * @implements HistogramSelection.allowsToggle()\n\t * Returns true if selection allows toggle\n\t */\n\tallowsToggle(){\n\t\treturn false;\n\t}\t\n\n\t/**\n\t * @public \n\t * @implements HistogramSelection.getSelectionPoints()\n\t * Returns histogram selection points\n\t */\n\tgetSelectionPoints(){\n\t\tvar result = [];\n\t\tvar selection = this.getSelection();\n\t\tselection.forEach((s, index)=>{\n\t\t\tresult.push({\n\t\t\t\tvalue:s.from\n\t\t\t});\n\n\t\t\tif (index == selection.length-1){\n\t\t\t\tresult.push({\n\t\t\t\t\tvalue:s.to\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}  \t\n}","import FilterHistogramSelectionImpl from \"./FilterHistogramSelectionImpl\";\nimport {SelectionTypes} from \"./HistogramSelection\";\n\n/**\n * @class\n * MultipleHistogramSelection representing histogram selection that support multiple selections\n */\nexport default class InvertedFilterHistogramSelectionImpl extends FilterHistogramSelectionImpl {\n\t/**\n\t * @param {HistogramData} histogramData\n\t * @param {Array} selection\n\t */\n    constructor(histogramData, selection) {\n\t\tsuper(histogramData, selection);\n\n\t\tthis._selection = this._getInvertedSelection(histogramData, selection);\n    }\n\n\n\t_getInvertedSelection(histogramData, selection){\n\t\tvar minMax = histogramData.getMinMax();\n\n\t\treturn [\n\t\t\t{\n\t\t\t\tfrom:minMax.min,\n\t\t\t\tto:selection[0].from\n\t\t\t},\n\t\t\t{\n\t\t\t\tfrom:selection[0].from,\n\t\t\t\tdisabled:true,\n\t\t\t\tto:selection[0].to\n\t\t\t},\n\t\t\t{\n\t\t\t\tfrom:selection[0].to,\n\t\t\t\tto:minMax.max\n\t\t\t}\n\t\t];\n\t}\n\n\t/**\n\t * @public\n\t * @returns {Array} histogram selection\n\t * @implements HistogramSelection.getOutputSelection()\n\t * Returns histogram selection \n\t */\n\tgetOutputSelection(){\n\t\treturn [\n\t\t\t{\n\t\t\t\tfrom:this._selection[1].from,\n\t\t\t\tto:this._selection[1].to\n\t\t\t}\n\t\t];\n\t}\t\n\n\t/**\n\t * @public\n\t * @implements HistogramSelection.getSelectionType()\n\t * Returns histogram selection\n\t */\n\tgetSelectionType(){\n\t\treturn SelectionTypes.INVERTED_FILTER;\n\t}\n\n\t/**\n\t * @public \n\t * @implements HistogramSelection.getSelectionPoints()\n\t * Returns histogram selection points\n\t */\n\tgetSelectionPoints(){\n\t\tvar result = super.getSelectionPoints();\n\t\t\n\t\tresult[0].hidden = true;\n\t\tresult[result.length-1].hidden = true;\n\n\t\treturn result;\n\t}  \t\n}","import DefaultHistogramSelectionImpl from \"./DefaultHistogramSelectionImpl\";\nimport MultipleHistogramSelectionImpl from \"./MultipleHistogramSelectionImpl\";\nimport FilterHistogramSelectionImpl from \"./FilterHistogramSelectionImpl\";\nimport InvertedFilterHistogramSelectionImpl from \"./InvertedFilterHistogramSelectionImpl\";\nimport {SelectionTypes} from \"./HistogramSelection\";\n\n/**\n * @class\n * HistogramSelection factory returns appropriate selection implementation\n */\nexport default class HistogramSelectionFactory {\n\t/**\n\t * @param {Object} options\n\t */\n\tconstructor(options) {\n\t\tthis._options = options;\n\t}\n\n\t/**\n\t * @public\n\t * @param {HistogramData} histogramData\n\t * @returns {HistogramSelection} returns histogram selection\n\t * Returns histogram selection\n\t */\n\tgetHistogramSelection(selection, histogramData){\t\t\n\t\t// use default histogram selection if selection is not provided\n\t\tif (!selection){\n\t\t\treturn new DefaultHistogramSelectionImpl(histogramData, this._options.selection);\n\t\t} else if (this._options.selectionType == SelectionTypes.FILTER){\n\t\t\treturn new FilterHistogramSelectionImpl(histogramData, selection);\n\t\t} else if (this._options.selectionType == SelectionTypes.INVERTED_FILTER){\n\t\t\treturn new InvertedFilterHistogramSelectionImpl(histogramData, selection);\n\t\t} else {\n\t\t\treturn new MultipleHistogramSelectionImpl(histogramData, selection);\n\t\t}\n\t}  \t\n}"],"names":["getHandlePositionOffsets","handle1","handle2","maskPadding","width","label1Box","getLabelBox","label2Box","conflictDiff","x","posDiff1","posDiff2","xMax","getOptionValue","optionValue","defaultOptionValue","Observable","events","_handlers","reduce","acc","cur","event","handler","this","push","handlers","index","indexOf","splice","args","i","length","apply","WIDTH","HEIGHT","MARGIN","INACTIVE_BAR_COLOR","INACTIVE_BAR_OPACITY","OVER_SELECTION_COLOR","OVER_SELECTION_OPACITY","SELECTION_COLOR","ENABLE_SELECTION_TOGGLE","FONT_SIZE","DEFAULT_COLORS","HistogramData","data","options","_histogramData","_loadHistogramData","_minMax","_calculateMinMax","_options","histogramData","d3","d","value","max","min","position","minMax","getMinMax","getValueRatio","valueRatio","Math","round","numOfBarsPerBucket","forEach","bucket","step","content","frequency","gradientIndex","HistogramHandle","groupEl","_observable","_handleEl","_handleLineEl","_handleCircleEl","_handleMaskEl","_handleMaskGradientEl","_handleLabelEl","_isOver","_groupEl","_index","_value","_initialValue","Number","_position","valueToPosition","_initialPosition","_labelSizeCache","_elements","_renderHandle","element","remove","_createHandleElement","_createHandleLineElement","_createHandleCircleElement","_createDragMaskElement","_createMaskGradientElement","_createDragLabelElement","_handleHoverState","_handleDrag","attr","eventName","on","parseInt","Defaults","_updateLabelPosition","node","getBBox","offset","height","text","setLabelOffset","setHoverState","unsetHoverState","classed","style","fire","xpos","positionToValue","_getLabelText","format","call","_onDrag","bind","_onStartDrag","_onEndDrag","label","innerHTML","getComputedTextLength","fontSize","textLength","_getComputedLabelTextLength","maskWidth","xPosition","append","selectAll","color","enter","_this2","HistogramSelectionRenderer","_histogramSelection","_overSelectionIndex","_rendered","_handles","_draggingHandle","_prevSelection","_animating","_destroyHandles","_selectionBars","handle","destroy","handleIndex","handleValue","promptHandler","then","promptResult","parseFloat","_this","points","getSelectionPoints","positions","map","point","sort","p1","p2","_updateSelectionPositions","_updateSelection","_renderHandles","selectionIndex","selection","disabled","enabled","target","allowsToggle","_toggleSelection","_onHandleClick","_onClick","histogramSelection","_animate","animate","getSelection","_prevHistogramData","_clear","_renderSelection","_handleClick","handles","slice","h1","h2","getXPosition","labelOffsets","PositionUtils","nodes","_updateSelectionControlsHoverState","g","selectionbar","_onSelectionMouseOut","_onSelectionMouseOver","p","pos","_this3","hidden","hide","_onHandleDrag","startSelectionSnapshot","JSON","stringify","disable","enable","getOutputSelection","barX","s","isLast","from","to","inactiveBarColor","overSelectionColor","barSelectionIndex","_getBarSelectionIndex","selectionColor","isOver","isDisabled","overSelectionOpacity","inactiveBarOpacity","opacity","selection1","selection2","data1","data2","onTransition","onComplete","s1","s2","_this4","transitions","frames","abs","t","duration","si","hi","bars","bar","fillBars","_this5","_getBarColor","_getBarOpacity","prevSelection","prevData","setHandleXPosition","setLabelPosition","_onSelectionTransition","barColor","showLabel","_this6","hideLabel","HistogramRenderer","_containerEl","_svgEl","_historyData","_xAxis","range","_yAxis","_prevData","_selectionRenderer","_labelsVisible","selector","ct","margin","svg","left","right","top","bottom","inactive","active","render","domain","getData","volume","_renderXAxis","_renderDataBars","refresh","showSelectionLabels","hideSelectionLabels","y","floor","ceil","removeChild","HistogramSelection","_selection","Object","assign","SelectionTypes","MultipleHistogramSelection","MULTI","result","DefaultHistogramSelectionImpl","colors","start","MultipleHistogramSelectionImpl","FilterHistogramSelectionImpl","FILTER","InvertedFilterHistogramSelectionImpl","_getInvertedSelection","INVERTED_FILTER","HistogramSelectionFactory","selectionType","Histogram","enableSelectionToggle","_histogramRenderer","_selectionFactory","off","isRendered","getHistogramSelection","String","setSelection"],"mappings":"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"}
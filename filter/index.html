<!DOCTYPE html>
<meta charset="utf-8">
<style>
    g * {
        font-size: 10px;
        font-family: Roboto;
    }

    g {
        border:1px solid #eeeeee;
    }

    /* BAR ======================================== */
    .bar {
        fill: #F1F1F1;
    }
    
    .bar.active {
        fill: #4AACE2;
    }

    /* BRUSH ======================================== */
    .x-axis>path {
        stroke: #F1F1F1;
    }

    .x-axis>.tick>text {
        fill:#7d7d7d;
    }

    /* BRUSH ======================================== */

    g.active .custom-handle {
        stroke:#4a4a4a;
        r:3.5;
    }

    g.inactive .custom-handle {
        stroke:#bababa;
        r:2.5;
    }

    g.brush-drag .custom-handle {
        stroke:#4a4a4a;
        r:3.5;
    }    

    .custom-handle {
        transition: r 0.1s ease-out;
        pointer-events: none;
    }

    .brush-axis-line {
        stroke:#4a4a4a;
        display: none;
        stroke-width: 1px;
    }

    .custom-handle-line {
        stroke:#4a4a4a;
        fill:#4a4a4a;
    }

    .handle {
        transition: all 0.05s ease-out;
    }
    
    .custom-handle--w:hover,
    .custom-handle--e:hover,

    .brush-drag-e .custom-handle--e,
    .brush-drag-w .custom-handle--w,

    .handle--w:hover~.custom-handle--w,    
    .handle--e:hover~.custom-handle--e {
        r: 4.5;
        stroke-width: 3px;
    }
    
    .custom-handle--w:hover,
    .custom-handle--e:hover,
    
    .handle--w:hover~.custom-handle-line--w,
    .handle--e:hover~.custom-handle-line--e,
    
    .handle--w:hover~.drag-label--w, 
    .handle--e:hover~.drag-label--e,
    .handle--w:hover~.drag-label-mask--w, 
    .handle--e:hover~.drag-label-mask--e,    

    .brush-drag-w .custom-handle-line--w,
    .brush-drag-e .custom-handle-line--e,

    .brush-drag-w .drag-label--w,
    .brush-drag-e .drag-label--e,
    .brush-drag-w .drag-label-mask--w,
    .brush-drag-e .drag-label-mask--e,

    .brush-drag-w .brush-axis-line,
    .brush-drag-e .brush-axis-line,

    .handle--w:hover~.brush-axis-line, 
    .handle--e:hover~.brush-axis-line

     {
        display: block;
        visibility: visible;
    }
    
    .brush>.selection {
        fill: rgba(0, 0, 0, 0);
        stroke: transparent;
        cursor: grab;
        cursor: -webkit-grab;
        cursor: -moz-grab;
    }

    .brush>.overlay.grabbing,
    .brush>.selection.grabbing {
        cursor: grabbing ;
        cursor: -webkit-grabbing ;
        cursor: -moz-grabbing ;
    }    

    /* DRAG LABEL ======================================== */
    .drag-label {
        visibility: hidden;
        fill:#4A4A4A;
    }
    .drag-label-mask {
        visibility: hidden;
        fill:url(#brush-mask-gradient);
    }
</style>

<body>
    <script src="//d3js.org/d3.v4.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <script>

        // =================================================== INIT, TODO: replace this by attributes object

        var width = 360;
        var height = 150;
        var margin = 25;
        var format = d3.format(",.0f");
        var container = document.body;
        var selection = [100, 200];

        d3.json("sample.json", (json) => {
            init(json.content);
        });

        // =================================================== FUNCTIONS

        /**
        * @param {Array} buckets
        */
        function init(buckets){
            var data = getData(buckets);

            var x = d3.scaleBand().range([0, width]);
            var y = d3.scaleLinear().range([height, 0]);
            
            var g = render(width, height, margin);
            var bars = renderBars(g, data, x, y);
            var xAxis = renderXAxis(g, data, x);
            var brush = renderBrush(g, data, x);

            select(g, data, x, brush);   
        }

        /**
        * Returns min max values for given data
        * @param {Array} data
        * @returns {Object} minMax.min
        * @returns {Object} minMax.max
        */
        function getXMinMax(data){
            var min = d3.min(data, function (d) { return d.value; });
            var max = d3.max(data, function (d) { return d.value; });

            return {
                min:min,
                max:max
            }
        }

        /**
        * Returns data values from selection 
        * @param {Array} data
        * @returns {Array} values
        */
        function getViewSelection(data){
            var minMax = getXMinMax(data);
            var range = minMax.max - minMax.min;
            var valueRatio = range / width;
            return [selection[0]/valueRatio-minMax.min, selection[1]/valueRatio-minMax.min];
        }

        /**
        * Returns selection from given values 
        * @param {Array} data
        * @returns {Array} selection
        */
        function getDataSelection(viewSelection, data){
            var minMax = getXMinMax(data);
            var range = minMax.max - minMax.min;
            var valueRatio = range / width;
            var selection = [viewSelection[0]*valueRatio+minMax.min, viewSelection[1]*valueRatio+minMax.min];
            return [format(selection[0]), format(selection[1])];
        }        

        /**
         * Triggers manual brush selection 
        * @param {d3.Selection} g
        * @param {Array} data
        * @param {d3.Axis} x
        * @param {d3.Brush} brush
        */
        function select(g, data, x, brush){
            g.select(".brush").call(brush.move, getViewSelection(data));
        }

        /**
        * @param {d3.Selection} g
        * @param {int} width
        * @param {int} height
        * @param {int} margin
        * @return {d3.Selection} 
        */
        function render(width, height, margin){
            var svgEl = d3.select(container).append("svg")
                .attr("width", width + margin * 2)
                .attr("height", height + margin * 2);

            var groupEl = svgEl.append("g")
                .classed("inactive", true)
                .attr("transform",
                "translate(" + margin + "," + margin + ")");

            svgEl.on("mouseover.hover", ()=>{
                groupEl.classed("active", true)
                groupEl.classed("inactive", false)
            })

            svgEl.on("mouseout.hover", ()=>{
                groupEl.classed("inactive", true)
                groupEl.classed("active", false)
            })

            return groupEl;
        };

        /**
        * @param {Array} buckets
        * @param {int} numOfBarsPerBucket - number of bars per column\
        * @returns {Array} data from given buckets 
        */
        function getData(buckets, numOfBarsPerBucket){
            var data = [];
            var numOfBarsPerBucket = width / buckets.length;
            buckets.forEach((bucket) => {
                var step = (bucket.max - bucket.min) / numOfBarsPerBucket;
                d3.range(bucket.min, bucket.max, step).forEach((value) => {
                    data.push({
                        value: value,
                        volume: bucket.content[0].frequency
                    });
                });
            });
            return data;
        };            

        /**
        * @param {d3.Selection} g
        * @param {Array} data
        * @param {d3.Axis} x
        * @param {d3.Axis} y
        * @return {d3.Selection} 
        */
        function renderBars(g, data, x, y) {
            // Scale the range of the data in the domains
            x.domain(data.map(function (d) {return d.value; }));
            y.domain([0, d3.max(data, function (d) { return d.volume; })]);

            // append the rectangles for the bar chart
            var bar = g.selectAll(".bar")
                .data(data)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", function (d) { return x(d.value); })
                .attr("width", x.bandwidth())
                .attr("y", function (d) { return Math.round(y(d.volume)); })
                .attr("height", function (d) { return Math.round(height - y(d.volume)); });

            return bar;
        };        

        function getBrushSelection(){
            var brushSelection = d3.event.selection;
            if (typeof brushSelection[0] != "undefined"){
                brushSelection[0] = Math.ceil(brushSelection[0]);
                brushSelection[1] = Math.round(brushSelection[1]);
            }

            return brushSelection;
        }

        /**
        * @param {d3.Selection} brushSelection brush selection 
        * @param {Array} data
        * @return {d3.Selection} brush selection
        */
        function handleSelectionConstrains(brushSelection, data){
            // handle when filter is on the left edge, by default, d3.js clears selection 
            // we need to set it to no equal to prevent this
            if (brushSelection[0] == 0 && brushSelection[1] == 0){
                return [0,1];
            // handle when filter is on the right edge, by default, d3.js clears selection 
            // we need to set it to no equal to prevent this                
            } else if (brushSelection[0] == width && brushSelection[1] == width){
                return [brushSelection[0]-1, brushSelection[1]];
            // handle when selection is equal and outside of edges, prevent equal selection              
            } else if (brushSelection[0] == brushSelection[1]){
                return [brushSelection[0], brushSelection[1]+1];
            // otherwise return given selection    
            } else {
                return brushSelection;
            }
        }

        /**
        * @param {d3.Selection} g
        * @param {Array} data
        * @param {d3.Axis} x
        * @param {int} numOfBarsPerBucket - number of bars per column\
        * @return {d3.Brush} 
        */
        function renderBrush(g, data, x) {
            // set class back to 'brush' when dragging ends so we can hide all hover decorators 
            var onbrushend = () => {
                gBrush.attr("class", "brush");
                gBrush.attr("data-start-handle", "");
                if (!d3.event.selection) {
                    // revert to old selection when nothing gets selected
                    // need to call this in setTimeout after current brushend completes
                    setTimeout(()=>{
                        select(g, data, x, brush);
                    });
                }
            }

            // create brushX and attach events
            var brush = d3.brushX()
                .extent([[0, 0], [width, height]])
                .on("start brush end", brushmoved)
                .handleSize(10)
                .on("end.drag", onbrushend);

            var initSelection;
            brush.on("start", ()=>{
                var selection = getBrushSelection();
                if (selection){
                    initSelection = d3.event.selection.slice(0);
                }
            });

            // brush moved handler where we need to handle bar color, handles and so on    
            function brushmoved(behaviour, type, target) {
                var s = getBrushSelection();

                if (s) {
                    s = handleSelectionConstrains(s, data);

                    // prevent brush when range is same (single click)
                    if (s[0] == s[1]){
                        return;
                    }
                // do nothing when there is no selection    
                } else {
                    return;
                }

                // we need to reorder left and right handle in DOM in order to keep handles accessible based on position
                if (s && s[0] < width/2){
                    leftHandle.parentNode.insertBefore(leftHandle, rightHandle);
                } else if (s && s[0]>width/2){
                    leftHandle.parentNode.insertBefore(rightHandle, leftHandle);
                }                    

                var brushClassName = target[0].getAttribute("class");
                var brushStartHandle = target[0].getAttribute("data-start-handle");
                // show both sides when dragging whole filter
                if (brushClassName == "brush"){
                    gBrush.attr("class", "brush brush-drag brush-drag-w brush-drag-e")
                }

                // handle flipping side when east handle is moved over west,
                // we need to show west handle instead
                if (brushStartHandle == "e" && initSelection[0] != s[0]){
                    gBrush.attr("class", "brush brush-drag brush-drag-w");
                } else if (brushStartHandle == "e"){
                    gBrush.attr("class", "brush brush-drag brush-drag-e");
                }

                // handle flipping side when wesst handle is moved over east,
                // we need to show east handle instead
                if (brushStartHandle == "w" && initSelection[1] != s[1]){
                    gBrush.attr("class", "brush brush-drag brush-drag-e");
                } else if (brushStartHandle == "w"){
                    gBrush.attr("class", "brush brush-drag brush-drag-w");
                }

                // handle bar colors
                var bar = g.selectAll(".bar");
                if (s === null) {
                    bar.classed("active", false);
                    handleLine.attr("display", "none");
                } else {
                    var sx = s.map(x);
                    handle.attr("display", null).attr("transform", function (d, i) { return "translate(" + s[i] + "," + height + ")"; });
                    handleLine.attr("transform", function (d, i) { return "translate(" + (s[i] - 1.5) + "," + 0 + ")"; });
                    axisLine.attr("x1", s[0]);
                    axisLine.attr("x2", s[1]);
                    bar.classed("active", function (d) {
                        var barX = x(d.value);
                        return barX >= s[0] && barX < s[1];
                    });
                }
            }

            // brush container
            var gBrush = g.append("g")
                .attr("class", "brush")
                .call(brush);

            var leftHandle = gBrush.select(".handle--w").node();
            var rightHandle = gBrush.select(".handle--e").node();                

            var axisLine = gBrush
                .append("line")
                .attr("class", "brush-axis-line")
                .attr("x1", 20)
                .attr("x2", 120)
                .attr("y1", height+0.5)
                .attr("y2", height+0.5);

            // create custom brush handles (cicles)    
            var handle = gBrush.selectAll(".custom-handle")
                .data([{ type: "w" }, { type: "e" }])
                .enter().append("circle")
                .attr("class", function (d) {
                    return "custom-handle custom-handle--" + d.type;
                })
                .attr("display", "none")
                .attr("fill", "#ffffff")
                .attr("fill-opacity", 1)
                .attr("stroke", "#000")
                .attr("stroke-width", 1)
                .attr("cursor", "ew-resize")
                .attr("r",3.5);
            
            // create handle line decorator, note that this is only visible on hover as per styling above
            var handleLine = gBrush.selectAll(".custom-handle-line")
                .data([{ type: "w" }, { type: "e" }])
                .enter().append("rect")
                .attr("class", function (d) {
                    return "custom-handle-line custom-handle-line--" + d.type;
                })
                .attr("display", "none")
                .attr("pointer-events", "none")
                .attr("fill", "#000000")
                .attr("width", 3)
                .attr("height", height - 5);

            // handle grabbing
            gBrush.select(".selection").on("mousedown.grab",function(){
                gBrush.select(".overlay").classed("grabbing", true);
                gBrush.select(".selection").classed("grabbing", true);
            })

            brush.on("end",()=>{
                gBrush.select(".overlay").classed("grabbing", false);
                gBrush.select(".selection").classed("grabbing", false);
            });
                              

            // we need to manually enable dragging on each handle as D3 doesn't seem to differentiate between dragging on east and west handles
            // need to investigate and potentially file an issue so that the handler passes handle info    
            gBrush.select(".handle--e").on("mousedown.handle", function () {
                gBrush.attr("class", "brush brush-drag-e");
                gBrush.attr("data-start-handle", "e");
            });

            gBrush.select(".handle--w").on("mousedown.handle", function () {
                gBrush.attr("class", "brush brush-drag-w");
                gBrush.attr("data-start-handle", "w")
            })

            var dragLabels = renderDragLabels(g, data, x, brush);

            return brush;
        }
        
        /**
        * @param {d3.Selection} g
        * @param {Array} data
        * @param {d3.axis} x
        * @return {d3.Selection} 
        */        
        function renderXAxis(g, data, x){
            // calculate min max as these are the only values shown on axis
            var xMin = d3.min(data, function (d) { return d.value; });
            var xMax = d3.max(data, function (d) { return d.value; });

            // create bottom axis
            var axis = d3.axisBottom(x)
                .tickValues([xMin, xMax])
                .tickSize(0)
                .tickFormat(format)
                .tickPadding(15);

            return g.append("g")
                .attr("transform", "translate(0," + height + ")")
                .attr("class", "x-axis")
                .call(axis);
        }

        /**
        * @param {d3.Selection} g
        * @param {d3.axis} x
        * @param {d3.Brush} brush
        * @return {d3.Selection} 
        */        
        function renderDragLabels(g, data, x, brush){
            // calculate min max as these are the only values shown on axis
            var xMin = d3.min(data, function (d) { return d.value; });
            var xMax = d3.max(data, function (d) { return d.value; });
            var range = xMax - xMin;
            var valueRatio = range / width;
            
            // drag mask, we need this in order to mask min/max values when drag label is over min/max labels
            var dragMask = g.select(".brush").selectAll(".drag-label-mask")
                .data([{ type: "w" }, { type: "e" }])
                .enter().append("rect")
                .attr("class", function (d) {
                    return "drag-label-mask drag-label-mask--" + d.type;
                });

            // drag label showing current filter range on hover
            var dragLabel = g.select(".brush").selectAll(".drag-label")
                .data([{ type: "w" }, { type: "e" }])
                .enter().append("text")
                .attr("class", function (d) {
                    return "drag-label drag-label--" + d.type;
                });

            var maskGradient = g.append("linearGradient")
                .attr("id", "brush-mask-gradient")
                .attr("gradientUnits", "userSpaceOnUse")
                .attr("y1", 0).attr("x1", 50)
                .attr("y2", 0).attr("x2", 0);

                maskGradient.selectAll("stop")
                .data([
                    {offset: "0%", color: "rgba(255,255,255,0)"},
                    {offset: "25%", color: "rgba(255,255,255,1)"},
                    {offset: "75%", color: "rgba(255,255,255,1)"},
                    {offset: "100%", color: "rgba(255,255,255,0)"}
                ])
                .enter().append("stop")
                .attr("offset", function(d) { return d.offset; })
                .attr("stop-color", function(d) { return d.color; });                

            // handle brush events
            brush.on("brush.label", ()=>{
                var s = getBrushSelection();
                // this happens when selection is collapsed to either min,min or max, max, D3 automatically destroys selection
                // which we don't reallyh want
                // we can extend selection to whole area if this happens? 
                if (s) {
                    s = handleSelectionConstrains(s, data);
                } else {
                    return;
                }

                selection = getDataSelection(s, data);
                
                dragLabel.text(function(d, i){
                    return selection[i];
                }).attr("transform", function (d, i) {
                    // we need to calculate text length so we can create mask and center text
                    var textLength = this.getComputedTextLength();
                    var maskPadding = 10;
                    var maskWidth = textLength + maskPadding*2;
                    
                    // position mask
                    dragMask.attr("transform", (d, i)=>{
                        return "translate(" + (s[i]-textLength/2 - maskPadding) + "," + (height+12)+ ")"; 
                    });
                    
                    maskGradient.attr("x1", maskWidth);

                    dragMask.attr("width", maskWidth);
                    dragMask.attr("height", 20);
                    dragMask.attr("fill", "white");

                    // position text
                    return "translate(" + (s[i]-textLength/2) + "," + (height + 22)+ ")"; 
                });
            });
            return dragLabel;
        }        
    </script>
</body>
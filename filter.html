<!DOCTYPE html>
<meta charset="utf-8">
<style>
    svg {
        font-size: 10px;
        font-family: Roboto;
    }
    /* BAR ======================================== */
    .bar {
        fill: #F1F1F1;
    }
    
    .bar.active {
        fill: #4AACE2;
    }

    /* BRUSH ======================================== */
    .x-axis>path {
        stroke: #F1F1F1;
    }

    .x-axis>.tick>text {
        fill:#7d7d7d;
    }    
    
    /* BRUSH ======================================== */

    .custom-handle {
        transition: r 0.1s ease-out;
        stroke:#4a4a4a;
        pointer-events: none;
    }

    .brush-axis-line {
        stroke:#4a4a4a;
        display: none;
        stroke-width: 1px;
    }

    .custom-handle-line {
        stroke:#4a4a4a;
        fill:#4a4a4a;
    }

    .handle {
        transition: all 0.05s ease-out;
    }
    
    .custom-handle--w:hover,
    .handle--w:hover~.custom-handle--w,
    .custom-handle--e:hover,
    .brush-drag-e .custom-handle--e,
    .brush-drag-w .custom-handle--w,
    .handle--e:hover~.custom-handle--e {
        r: 4.5;
        stroke-width: 3px;
    }
    
    .custom-handle--w:hover,
    .custom-handle--e:hover,
    
    .handle--w:hover~.custom-handle-line--w,
    .handle--e:hover~.custom-handle-line--e,
    
    .handle--w:hover~.drag-label--w, 
    .handle--e:hover~.drag-label--e,
    .handle--w:hover~.drag-label-mask--w, 
    .handle--e:hover~.drag-label-mask--e,    

    .brush-drag-w .custom-handle-line--w,
    .brush-drag-e .custom-handle-line--e,

    .brush-drag-w .drag-label--w,
    .brush-drag-e .drag-label--e,
    .brush-drag-w .drag-label-mask--w,
    .brush-drag-e .drag-label-mask--e,

    .brush-drag-w .brush-axis-line,
    .brush-drag-e .brush-axis-line,

    .handle--w:hover~.brush-axis-line, 
    .handle--e:hover~.brush-axis-line

     {
        display: block;
        visibility: visible;
    }
    
    .brush>.selection {
        fill: rgba(0, 0, 0, 0);
        stroke: transparent;
    }

    /* DRAG LABEL ======================================== */
    .drag-label {
        visibility: hidden;
        fill:#7d7d7d;
    }
    .drag-label-mask {
        visibility: hidden;
    }
</style>

<body>
    <script src="//d3js.org/d3.v4.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <script>

        // =================================================== INIT, TODO: replace this by attributes object

        var width = 360;
        var height = 200;
        var margin = 25;
        var axisTickFormat = ",.0f";
        var container = document.body;
        var selection = [100, 200];

        d3.json("sample.json", (json) => {
            init(json.content);
        });

        // =================================================== FUNCTIONS

        /**
        * @param {Array} buckets
        */
        function init(buckets){
            var data = getData(buckets);

            var x = d3.scaleBand().range([0, width]);
            var y = d3.scaleLinear().range([height, 0]);
            
            var svg = renderSVG(width, height, margin);
            var bars = renderBars(svg, data, x, y);
            var xAxis = renderXAxis(svg, data, x);
            var brush = renderBrush(svg, data, x);

            select(svg, data, x, brush);   
        }

        function select(svg, data, x, brush){
            // calculate min max as these are the only values shown on axis
            var xMin = d3.min(data, function (d) { return d.value; });
            var xMax = d3.max(data, function (d) { return d.value; });
            var range = xMax - xMin;
            var valueRatio = range / width;
            svg.select(".brush").call(brush.move, [selection[0]/valueRatio-xMin, selection[1]/valueRatio-xMin]);
        }

        /**
        * @param {d3.Selection} svg
        * @param {int} width
        * @param {int} height
        * @param {int} margin
        * @return {d3.Selection} 
        */
        function renderSVG(width, height, margin){
            return d3.select(container).append("svg")
                .attr("width", width + margin * 2)
                .attr("height", height + margin * 2)
                .append("g")
                .attr("transform",
                "translate(" + margin + "," + margin + ")");
        };

        /**
        * @param {Array} buckets
        * @param {int} numOfBarsPerBucket - number of bars per column\
        * @returns {Array} data from given buckets 
        */
        function getData(buckets, numOfBarsPerBucket){
            var data = [];
            var numOfBarsPerBucket = width / buckets.length;
            buckets.forEach((bucket) => {
                var step = (bucket.max - bucket.min) / numOfBarsPerBucket;
                d3.range(bucket.min, bucket.max, step).forEach((value) => {
                    data.push({
                        value: value,
                        volume: bucket.content[0].frequency
                    });
                });
            });
            return data;
        };            

        /**
        * @param {d3.Selection} svg
        * @param {Array} data
        * @param {d3.Axis} x
        * @param {d3.Axis} y
        * @return {d3.Selection} 
        */
        function renderBars(svg, data, x, y) {
            // Scale the range of the data in the domains
            x.domain(data.map(function (d) {return d.value; }));
            y.domain([0, d3.max(data, function (d) { return d.volume; })]);

            // append the rectangles for the bar chart
            var bar = svg.selectAll(".bar")
                .data(data)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", function (d) { return x(d.value); })
                .attr("width", x.bandwidth())
                .attr("y", function (d) { return Math.round(y(d.volume)); })
                .attr("height", function (d) { return Math.round(height - y(d.volume)); });

            return bar;
        };        

        /**
        * @param {d3.Selection} svg
        * @param {Array} data
        * @param {d3.Axis} x
        * @param {int} numOfBarsPerBucket - number of bars per column\
        * @return {d3.Brush} 
        */
        function renderBrush(svg, data, x) {
            // set class back to 'brush' when dragging ends so we can hide all hover decorators 
            var onbrushend = () => {
                gBrush.attr("class", "brush")
                if (!d3.event.selection) {
                    // revert to old selection when nothing gets selected
                    // need to call this in setTimeout after current brushend completes
                    setTimeout(()=>{
                        select(svg, data, x, brush);
                    });
                    
                }
            }

            // create brushX and attach events
            var brush = d3.brushX()
                .extent([[0, 0], [width, height]])
                .on("start brush end", brushmoved)
                .handleSize(10)
                .on("end.drag", onbrushend);

            // brush moved handler where we need to handle bar color, handles and so on    
            function brushmoved() {
                var s = d3.event.selection;
                if (s && s[0] === s[1]) {
                    return;
                };

                // TODO: detect which handle starts dragging
                var brushClassName = arguments[2][0].getAttribute("class");

                if (brushClassName == "brush"){
                    gBrush.attr("class", "brush brush-drag-w brush-drag-e")
                }

                var bar = svg.selectAll(".bar");
                if (s == null) {
                    bar.classed("active", false);
                    handleLine.attr("display", "none");
                } else {
                    var sx = s.map(x);
                    handle.attr("display", null).attr("transform", function (d, i) { return "translate(" + s[i] + "," + height + ")"; });
                    handleLine.attr("transform", function (d, i) { return "translate(" + (s[i] - 1.5) + "," + 0 + ")"; });
                    axisLine.attr("x1", s[0]);
                    axisLine.attr("x2", s[1]);
                    bar.classed("active", function (d) {
                        var barX = x(d.value);
                        return barX >= s[0] && barX < s[1];
                    });
                }
            }

            // brush container
            var gBrush = svg.append("g")
                .attr("class", "brush")
                .call(brush);

            var axisLine = gBrush
                .append("line")
                .attr("class", "brush-axis-line")
                .attr("x1", 20)
                .attr("x2", 120)
                .attr("y1", height+0.5)
                .attr("y2", height+0.5);

            // create custom brush handles (cicles)    
            var handle = gBrush.selectAll(".custom-handle")
                .data([{ type: "w" }, { type: "e" }])
                .enter().append("circle")
                .attr("class", function (d) {
                    return "custom-handle custom-handle--" + d.type;
                })
                .attr("display", "none")
                .attr("fill", "#ffffff")
                .attr("fill-opacity", 1)
                .attr("stroke", "#000")
                .attr("stroke-width", 1)
                .attr("cursor", "ew-resize")
                .attr("r", 3.5);
            
            // create handle line decorator, note that this is only visible on hover as per styling above
            var handleLine = gBrush.selectAll(".custom-handle-line")
                .data([{ type: "w" }, { type: "e" }])
                .enter().append("rect")
                .attr("class", function (d) {
                    return "custom-handle-line custom-handle-line--" + d.type;
                })
                .attr("display", "none")
                .attr("pointer-events", "none")
                .attr("fill", "#000000")
                .attr("width", 3)
                .attr("height", height - 5);

            // we need to manually enable dragging on each handle as D3 doesn't seem to differentiate between dragging on east and west handles
            // need to investigate and potentially file an issue so that the handler passes handle info    
            gBrush.select(".handle--e").on("mousedown", function () {
                gBrush.attr("class", "brush brush-drag-e")
            });

            gBrush.select(".handle--w").on("mousedown", function () {
                gBrush.attr("class", "brush brush-drag-w")
            })

            var dragLabels = renderDragLabels(svg, data, x, brush);

            return brush;
        }
        
        /**
        * @param {d3.Selection} svg
        * @param {Array} data
        * @param {d3.axis} x
        * @return {d3.Selection} 
        */        
        function renderXAxis(svg, data, x){
            // calculate min max as these are the only values shown on axis
            var xMin = d3.min(data, function (d) { return d.value; });
            var xMax = d3.max(data, function (d) { return d.value; });

            // create bottom axis
            var axis = d3.axisBottom(x)
                .tickValues([xMin, xMax])
                .tickSize(0)
                .tickFormat(d3
                .format(axisTickFormat))
                .tickPadding(15);

            return svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .attr("class", "x-axis")
                .call(axis);
        }

        /**
        * @param {d3.Selection} svg
        * @param {d3.axis} x
        * @param {d3.Brush} brush
        * @return {d3.Selection} 
        */        
        function renderDragLabels(svg, data, x, brush){
            // calculate min max as these are the only values shown on axis
            var xMin = d3.min(data, function (d) { return d.value; });
            var xMax = d3.max(data, function (d) { return d.value; });
            var range = xMax - xMin;
            var valueRatio = range / width;
            
            // drag mask, we need this in order to mask min/max values when drag label is over min/max labels
            var dragMask = svg.select(".brush").selectAll(".drag-label-mask")
                .data([{ type: "w" }, { type: "e" }])
                .enter().append("rect")
                .attr("class", function (d) {
                    return "drag-label-mask drag-label-mask--" + d.type;
                });

            // drag label showing current filter range on hover
            var dragLabel = svg.select(".brush").selectAll(".drag-label")
                .data([{ type: "w" }, { type: "e" }])
                .enter().append("text")
                .attr("class", function (d) {
                    return "drag-label drag-label--" + d.type;
                });

            // handle brush events
            brush.on("brush.label", ()=>{
                var s = d3.event.selection;
                selection = s.map(function(value, index){
                    return Math.round(value*valueRatio+xMin);
                });
                
                dragLabel.text(function(d, i){
                    //FIME: handle floats? 
                    return selection[i];
                }).attr("transform", function (d, i) {
                    // we need to calculate text length so we can create mask and center text
                    var textLength = this.getComputedTextLength();
                    
                    // position mask
                    dragMask.attr("transform", (d, i)=>{
                        return "translate(" + (s[i]-textLength/2) + "," + (height+12)+ ")"; 
                    });

                    dragMask.attr("width", textLength);
                    dragMask.attr("height", 20);
                    dragMask.attr("fill", "white");

                    // position text
                    return "translate(" + (s[i]-textLength/2) + "," + (height + 22)+ ")"; 
                });
            });
            return dragLabel;
        }        
    </script>
</body>
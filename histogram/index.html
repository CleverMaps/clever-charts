<!DOCTYPE html>
<meta charset="utf-8">
<style>
    g * {
        font-size: 10px;
        font-family: Roboto;
    }

    g {
        border:1px solid #eeeeee;
    }

    g .invisiblebar {
        cursor:pointer;
    }

    /* BAR ======================================== */

    /* BRUSH ======================================== */
    .x-axis>path {
        stroke: #F1F1F1;
    }

    g > text {
        user-select: none;
    }

    .x-axis>.tick>text {
        fill:#7d7d7d;
    }

    /* BRUSH ======================================== */

    g.active .custom-handle-circle {
        stroke:#4a4a4a;
    }

    g.inactive:not(.dragging) .custom-handle-circle {
        stroke:#bababa;
        r:2.5;
    }


    g.inactive.dragging .custom-handle-circle {
        stroke:#4a4a4a;
    }    

    g.brush-drag .custom-handle-circle {
        stroke:#4a4a4a;
    }    

    .custom-handle-circle {
        transition: r 0.1s ease-out;
        pointer-events: none;
    }

    .brush-axis-line {
        stroke:#4a4a4a;
        display: none;
        stroke-width: 1px;
    }

    .custom-handle-line {
        stroke-width:0;
        fill:#4A4A4A;
        pointer-events: none;
    }

    .handle {
        transition: all 0.05s ease-out;
    }
    
    .brush>.selection {
        fill: rgba(0, 0, 0, 0);
        stroke: transparent;
        cursor: grab;
        cursor: -webkit-grab;
        cursor: -moz-grab;
    }

    .brush>.overlay.grabbing,
    .brush>.selection.grabbing {
        cursor: grabbing ;
        cursor: -webkit-grabbing ;
        cursor: -moz-grabbing ;
    }    

    /* DRAG LABEL ======================================== */
    .drag-label {
        fill:#4A4A4A;
    }
    .drag-label-mask {
        fill:url(#brush-mask-gradient);
    }
</style>

<body>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/4.8.0/d3.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js"></script>
    
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <script>

        // =================================================== INIT, TODO: replace this by attributes object

        var width = 360;
        var height = 150;
        var margin = 25;
        var format = d3.format(",.0f");
        var container = document.body;
        var inactiveCategoryColor = "#f0f0f0";
        var hoverCategoryColor = "#ffea00";

        var selection = [
            {
                from:1,
                to:50,
                color:"#71CFFF"
            }, {
                from:50,
                to:100,
                color:"#66D842"
            }, {
                from:100,
                to:150,
                color:"#FFC600"
            }, {
                from:150,
                to:200,
                color:"#FF9271"
            }
        ];

        var overCategoryIndex = -1;

        var viewSelection;
        var positionToData;
        var valueToPosition;

        d3.json("sample.json", (json) => {
            init(json.content);
        });

        // =================================================== FUNCTIONS

        /**
        * @param {Array} buckets
        */
        function init(buckets){
            var data = getData(buckets);
            var minMax = getXMinMax(data);
            var range = minMax.max - minMax.min;
            var valueRatio = range / width;

            positionToValue = function(position){
                return format(position*valueRatio+minMax.min);
            }

            valueToPosition = function(value){
                return parseInt((value)/valueRatio);
            }

            var x = d3.scaleBand().range([0, width]);
            var y = d3.scaleLinear().range([height, 0]);
            
            var g = render(width, height, margin);
            var bars = renderBars(g, data, x, y);
            renderSelection(g, x);
            var xAxis = renderXAxis(g, data, x);   
            renderSelectionControls(g, x, data);

            handleHoverState(g, x);
            handleClick(g, x, data, minMax);
        }

        function toggleCategory(categoryIndex, g, x){
            selection[categoryIndex].disabled ^= true;
            renderSelection(g, x);
        }

        function handleClick(g, x, data, minMax){
            g.on("click", (target)=>{
                var target = d3.select(d3.event.target);
                var categoryIndex = target.attr("data-category-index");
                if (categoryIndex != null){
                    toggleCategory(categoryIndex, g, x)
                }

                var handleIndex = target.attr("data-handle-index");
                if (handleIndex != null){
                    var promptResult = prompt("value", target.attr("data-handle-value"));
                    var positions = g.selectAll(".custom-handle").nodes().map(handle=>{
                        return parseInt(d3.select(handle).attr("x"))+5;
                    });

                    promptResult = Math.min(minMax.max, promptResult);
                    promptResult = Math.max(minMax.min, promptResult);
                    positions[handleIndex] = valueToPosition(promptResult);

                    positions = positions.sort((p1, p2)=>{
                        return p1-p2;
                    });
                    updateSelection(positions, g, x);
                    destroySelectionControls(g);   
                    renderSelectionControls(g, x, data);

                }
            })
        }

        function fireEvent(eventName, eventValue){
            console.log("Firing " + eventName + ": "+eventValue);
        }

        function handleHoverState(g, x){
            // we need to create cancellable task as in some cases, mouseover is not triggered if 
            // quickly moving mouse outside of bars. In order to handle this, we need to handle 
            // mouseout but only when it's outside of bars which only happens when subsequent 
            // mouseover doesn't cancel this task
            var mouseOutTask = _.debounce(onMouseOut, 10);
            g.on("mouseout", mouseOutTask);

            g.on("mouseover", ()=>{
                mouseOutTask.cancel();
                var categoryIndex = d3.select(d3.event.target).attr("data-category-index");
                if (overCategoryIndex != categoryIndex){
                    overCategoryIndex = categoryIndex;
                    renderSelection(g, x);
                    
                    if (overCategoryIndex == null){
                        fireEvent("selectionHoverChange", null);
                    } else {
                        fireEvent("selectionHoverChange", overCategoryIndex);
                    }
                }
            })

            function onMouseOut(){
                overCategoryIndex = null;
                renderSelection(g, x);
            }

        }

        /**
        * Returns bar color based on X position
        * @returns {String} color
        */
        function getBarCategoryIndex(barX){
            for (var i=0;i<selection.length;i++){
                var s = selection[i];
                var within = barX >= valueToPosition(s.from) && barX < valueToPosition(s.to);
                if (within) return i;
            }

            return null;
        }

        /**
        * Renders selection
        * @param {d3.Selection} g
        * @param {d3.Axis} x
        */
        function renderSelection(g, x){
            // handle bar category
            g.selectAll(".invisiblebar").attr("data-category-index", function (d) {
                var barX = x(d.value);
                return getBarCategoryIndex(barX);
            });

            // handle bar colors
            g.selectAll(".bar").attr("fill", function (d) {
                var barX = x(d.value);
                var barCategoryIndex = getBarCategoryIndex(barX);
                if (barCategoryIndex == null){
                    return inactiveCategoryColor;
                } else if (selection[barCategoryIndex].disabled){
                    return inactiveCategoryColor;
                } if (overCategoryIndex == barCategoryIndex){
                    return hoverCategoryColor;
                } else {
                    return selection[barCategoryIndex].color;                    
                }
            });
        }

        /**
        * Updates selectino with new positions
        * @param {Array} positions
        * @param {d3.Selection} g
        * @param {d3.Axis} x
        */
        function updateSelection(positions, g, x){
            positions.forEach((p, index)=>{
                if (index>selection.length-1){
                    return;
                }
                selection[index].from = positionToValue(p);
                selection[index].to = positionToValue(positions[index+1]);
            });

            renderSelection(g, x);
        }


        // /**
        // * @param {d3.Selection} g
        // * @param {int} position  
        // * Creates drag handle
        // */
        // function updateHandle(g, value, x, handleIndex){
        //     var position = valueToPosition(value);
        //     d3.select(g.selectAll(".custom-handle").nodes()[handleIndex]).attr("x", position-5).attr("data-handle-value", value);
        //     d3.select(g.selectAll(".custom-handle-circle").nodes()[handleIndex]).attr("transform", "translate(" + position + "," + height + ")");
        //     d3.select(g.selectAll(".custom-handle-line").nodes()[handleIndex]).attr("x", position-2);
        // }

        /**
        * @param {d3.Selection} g
        * @param {int} position  
        * Creates drag handle
        */
        function createHandle(g, value, x, handleIndex){
            var position = valueToPosition(value);
            // handle
            var handle = g.append("rect")
            .attr("class", "custom-handle")
            .attr("fill-opacity", 0)
            .attr("data-handle-index", handleIndex)
            .attr("data-handle-value", value)
            .attr("cursor", "ew-resize")
            .attr("width",10)
            .attr("height", height+5)
            .attr("x", position-5);

            // handle line decorator
            var line = g.append("rect")
            .attr("class", "custom-handle-line")
            .attr("width",4)
            .attr("height", height)
            .attr("fill-opacity", 0)
            .attr("x", position-2);

            // circle decorator
            var circle = g.append("circle")
                .attr("class", "custom-handle-circle")
                .attr("transform", "translate(" + position + "," + height + ")")
                .attr("fill", "#ffffff")
                .attr("fill-opacity", 1)
                .attr("stroke", "#000")
                .attr("stroke-width", 1)
                .attr("cursor", "ew-resize")
                .attr("r",3.5); 

            
            // drag mask, we need this in order to mask min/max values when drag label is over min/max labels
            var dragMask = g.append("rect")
                .attr("class", "drag-label-mask")
                .attr("visibility", "hidden");          

            var maskGradient = g.append("linearGradient")
                .attr("id", "brush-mask-gradient")
                .attr("gradientUnits", "userSpaceOnUse")
                .attr("y1", 0).attr("x1", 50)
                .attr("y2", 0).attr("x2", 0);

                maskGradient.selectAll("stop")
                .data([
                    {offset: "0%", color: "rgba(255,255,255,0)"},
                    {offset: "25%", color: "rgba(255,255,255,1)"},
                    {offset: "75%", color: "rgba(255,255,255,1)"},
                    {offset: "100%", color: "rgba(255,255,255,0)"}
                ])
                .enter().append("stop")
                .attr("offset", function(d) { return d.offset; })
                .attr("stop-color", function(d) { return d.color; });                        

            // drag label
            var dragLabel = g.append("text")
                .attr("class", function (d) {
                    return "drag-label";
                })
                .attr("fill-opacity", 0)
                .text(function(d, i){
                    return positionToValue(position);
                }).attr("transform", function(){
                    return updateLabelPosition(this, position);
                });          

                      
            
            // handle hover state
            var isOver = false;
            function setOverState(){
                line.attr("fill-opacity", 1);
                dragLabel.attr("fill-opacity", 1);
                dragMask.attr("visibility", "visible");
                circle.attr("r", 4.5).attr("stroke-width", 3);
            }

            function unsetOverState(){
                line.attr("fill-opacity", 0);
                dragLabel.attr("fill-opacity", 0);
                dragMask.attr("visibility", "hidden");
                circle.attr("r", 3.5).attr("stroke-width", 1);
            }

            // line hover effect
            handle.on("mouseover", ()=>{
                isOver = true;
                setOverState();
            })
            handle.on("mouseout", ()=>{
                isOver = false;
                unsetOverState();
            })                

            // handle drag
            handle.call(d3.drag()
                .on("drag", drag)
                .on("start", startdrag)
                .on("end", enddrag));

            function startdrag(){
                g.classed("dragging", true);
                g.selectAll(".custom-handle, .custom-handle-circle, .custom-handle-line, .bar, .invisiblebar").attr("pointer-events", "none");

                handle.attr("pointer-events", "all");
                line.attr("pointer-events", "all");
                circle.attr("pointer-events", "all");
            }

            function enddrag(){
                g.classed("dragging", false);
                g.selectAll(".custom-handle, .custom-handle-circle, .custom-handle-line, .bar, .invisiblebar").attr("pointer-events", "all");

                if (!isOver){
                    unsetOverState();
                }
            }

            function updateLabelPosition (label, position) {
                // we need to calculate text length so we can create mask and center text
                var textLength = label.getComputedTextLength();
                var maskPadding = 10;
                var maskWidth = textLength + maskPadding*2;
                var xPosition = position-textLength/2;

                // fix label position so it matches axis start position 
                if (xPosition<width/2){
                    xPosition+=1;
                }

                // position mask
                dragMask.attr("transform", (d, i)=>{
                    return "translate(" + (xPosition - maskPadding) + "," + (height+12)+ ")"; 
                });
                
                maskGradient.attr("x1", maskWidth);
                dragMask.attr("width", maskWidth);
                dragMask.attr("height", 20);
                dragMask.attr("fill", "white");                

                // position text
                return "translate(" + (xPosition) + "," + (height + 22)+ ")"; 
            };

            function drag() {
               var xpos = parseInt(Math.max(Math.min(d3.event.x, width), 0));
               handle.attr("x", xpos-5);
               line.attr("x", xpos-2);
               circle.attr("transform", "translate(" + xpos + "," + height + ")");
               handle.attr("data-handle-value", positionToValue(xpos))

               setOverState();

               var positions = g.selectAll(".custom-handle").nodes().map(handle=>{
                   return parseInt(d3.select(handle).attr("x"))+5;
               }).sort((p1, p2)=>{
                   return p1-p2;
               });

               updateSelection(positions, g, x);

               dragLabel.text(function(){
                    return positionToValue(xpos);
                }).attr("transform", function(){
                    return updateLabelPosition(this, xpos);
                });  
                      
            }
        }

        /**
        * Renders selection
        * @param {d3.Selection} g
        * @param {d3.Axis} x
        * @param {Array} data
        */
        function renderSelectionControls(g, x, data){
            selection.forEach((s, index)=>{
                createHandle(g, s.from, x, index);
                if (index == selection.length-1){
                    createHandle(g, s.to, x, index);
                }
                
            });
        }

        /**
        * Destroy controls
        * @param {d3.Selection} g
        */
        function destroySelectionControls(g){
            g.selectAll(".custom-handle, .custom-handle-circle, .custom-handle-line, .drag-label,.drag-label-mask").remove();
        }

        /**
        * Returns min max values for given data
        * @param {Array} data
        * @returns {Object} minMax.min
        * @returns {Object} minMax.max
        */
        function getXMinMax(data){
            var min = d3.min(data, function (d) { return d.value; });
            var max = d3.max(data, function (d) { return d.value; });

            return {
                min:min,
                max:max
            }
        }    

        /**
        * @param {d3.Selection} g
        * @param {int} width
        * @param {int} height
        * @param {int} margin
        * @return {d3.Selection} 
        */
        function render(width, height, margin){
            var svgEl = d3.select(container).append("svg")
                .attr("width", width + margin * 2)
                .attr("height", height + margin * 2);

            var groupEl = svgEl.append("g")
                .classed("inactive", true)
                .attr("transform",
                "translate(" + margin + "," + margin + ")");

            svgEl.on("mouseover.hover", ()=>{
                groupEl.classed("active", true)
                groupEl.classed("inactive", false)
            })

            svgEl.on("mouseout.hover", ()=>{
                groupEl.classed("inactive", true)
                groupEl.classed("active", false)
            })

            return groupEl;
        };

        /**
        * @param {Array} buckets
        * @param {int} numOfBarsPerBucket - number of bars per column\
        * @returns {Array} data from given buckets 
        */
        function getData(buckets, numOfBarsPerBucket){
            var data = [];
            var numOfBarsPerBucket = width / buckets.length;
            buckets.forEach((bucket) => {
                var step = (bucket.max - bucket.min) / numOfBarsPerBucket;
                d3.range(bucket.min, bucket.max, step).forEach((value) => {
                    data.push({
                        value: value,
                        volume: bucket.content[0].frequency
                    });
                });
            });
            return data;
        };            

        /**
        * @param {d3.Selection} g
        * @param {Array} data
        * @param {d3.Axis} x
        * @param {d3.Axis} y
        * @return {d3.Selection} 
        */
        function renderBars(g, data, x, y) {
            // Scale the range of the data in the domains
            x.domain(data.map(function (d) {return d.value; }));
            y.domain([0, d3.max(data, function (d) { return d.volume; })]);

            // append the rectangles for the bar chart
            var bar = g.selectAll(".bar")
                .data(data)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", function (d) { return x(d.value); })
                .attr("width", x.bandwidth())
                .attr("y", function (d) { return Math.round(y(d.volume)); })
                .attr("height", function (d) { return Math.round(height - y(d.volume)); });

            // space filling rectangles
            g.selectAll(".invisiblebar")
                .data(data)
                .enter().append("rect")
                .attr("class", "invisiblebar")
                .attr("x", function (d) { return x(d.value); })
                .attr("width", x.bandwidth())
                .attr("y", 0)
                .attr("fill", "transparent")
                .attr("height", height);                

            return bar;
        };        
        
        /**
        * @param {d3.Selection} g
        * @param {Array} data
        * @param {d3.axis} x
        * @return {d3.Selection} 
        */        
        function renderXAxis(g, data, x){
            // calculate min max as these are the only values shown on axis
            var xMin = d3.min(data, function (d) { return d.value; });
            var xMax = d3.max(data, function (d) { return d.value; });

            // create bottom axis
            var axis = d3.axisBottom(x)
                .tickValues([xMin, xMax])
                .tickSize(0)
                .tickFormat(format)
                .tickPadding(15);

            return g.append("g")
                .attr("transform", "translate(0," + height + ")")
                .attr("class", "x-axis")
                .call(axis);
        }

    </script>
</body>
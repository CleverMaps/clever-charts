<!DOCTYPE html>
<meta charset="utf-8">
<style>
    g * {
        font-size: 10px;
        font-family: Roboto;
    }

    g {
        border:1px solid #eeeeee;
    }

    g .selectionbar {
        cursor:pointer;
    }

    /* BAR ======================================== */

    /* BRUSH ======================================== */
    .x-axis>path {
        stroke: #F1F1F1;
    }

    g > text {
        user-select: none;
    }

    .x-axis>.tick>text {
        fill:#7d7d7d;
    }

    /* BRUSH ======================================== */

    g.active .custom-handle-circle {
        stroke:#4a4a4a;
    }

    g.inactive:not(.dragging) .custom-handle-circle {
        stroke:#bababa;
        r:2.5;
    }


    g.inactive.dragging .custom-handle-circle {
        stroke:#4a4a4a;
    }    

    g.brush-drag .custom-handle-circle {
        stroke:#4a4a4a;
    }    

    .custom-handle-circle {
        transition: r 0.1s ease-out;
        pointer-events: none;
    }

    .brush-axis-line {
        stroke:#4a4a4a;
        display: none;
        stroke-width: 1px;
    }

    .custom-handle-line {
        stroke-width:0;
        fill:#4A4A4A;
        pointer-events: none;
    }

    .handle {
        transition: all 0.05s ease-out;
    }
    
    .brush>.selection {
        fill: rgba(0, 0, 0, 0);
        stroke: transparent;
        cursor: grab;
        cursor: -webkit-grab;
        cursor: -moz-grab;
    }

    .brush>.overlay.grabbing,
    .brush>.selection.grabbing {
        cursor: grabbing ;
        cursor: -webkit-grabbing ;
        cursor: -moz-grabbing ;
    }    

    /* DRAG LABEL ======================================== */
    .drag-label {
        fill:#4A4A4A;
    }
</style>

<body>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/4.8.0/d3.min.js"></script>
    
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <script>

        // =================================================== INIT, TODO: replace this by attributes object

        var width = 360;
        var height = 150;
        var margin = 25;
        var format = d3.format(",.0f");
        var container = document.body;
        var inactiveCategoryColor = "#f0f0f0";
        var hoverCategoryColor = "#ffea00";
        var maskPadding = 10;                 

        var selection = [
            {
                from:100000,
                to:8400000,
                color:"#e6f3fb"
            }, {
                from:8400000,
                to:16800000,
                color:"#cbe7f6"
            }, {
                from:16800000,
                to:25200000,
                color:"#b1dbf2"
            }, {
                from:25200000,
                to:33600000,
                color:"#98cfee"
            }, {
                from:33600000,
                to:41983333,
                color:"#7ec4ea"
            }
        ];

        var overCategoryIndex = null;

        var viewSelection;
        var positionToData;
        var valueToPosition;

        d3.json("sample.json", (json) => {
            init(json.content);
        });

        // =================================================== FUNCTIONS

        /**
        * @param {Array} buckets
        */
        function init(buckets){
            var data = getData(buckets);
            var minMax = getXMinMax(data);
            var range = minMax.max - minMax.min;
            var valueRatio = range / width;

            positionToValue = function(position){
                return position*valueRatio+minMax.min;
            }

            valueToPosition = function(value){
                return value/valueRatio-minMax.min/valueRatio;
            }

            var x = d3.scaleBand().range([0, width]);
            var y = d3.scaleLinear().range([height, 0]);
            var g = render(width, height, margin);
            
            renderBars(g, data, x, y);
            updateSelection(g, x);
            renderXAxis(g, data, x);   
            updateSelectionControls(g, x, data);

            handleHoverState(g, x);
            handleClick(g, x, data, minMax);
        }

        function toggleCategory(categoryIndex, g, x){
            selection[categoryIndex].disabled ^= true;
            updateSelection(g, x);
        }

        function handleClick(g, x, data, minMax){
            g.on("click", (target)=>{
                var target = d3.select(d3.event.target);
                var categoryIndex = target.attr("data-category-index");
                if (categoryIndex != null){
                    toggleCategory(categoryIndex, g, x)
                }

                var handleIndex = target.attr("data-handle-index");
                if (handleIndex != null){
                    var promptResult = prompt("value", target.attr("data-handle-value"));
                    if (promptResult == null){
                        return;
                    }

                    promptResult = Math.min(minMax.max, promptResult);
                    promptResult = Math.max(minMax.min, promptResult);
                    
                    var points = getSelectionPoints();
                    points[handleIndex] = promptResult;
                    var positions = points.map(valueToPosition);
                    
                    updateSelectionPositions(positions, g, x);
                    destroySelectionControls(g);   
                    updateSelectionControls(g, x, data);
                }
            })
        }

        function fireEvent(eventName, eventValue){
            console.log("Firing " + eventName + ": "+eventValue);
        }

        // we need to get nth element based on horizontal position
        function getNthElement(s, i){
            var nodes = s.nodes();
            nodes.sort((n1,n2)=>{
                return n1.getBoundingClientRect().left - n2.getBoundingClientRect().left
            });

            return d3.select(nodes[i]);
        }

        function updateSelectionControlsHoverState(g, categoryIndex){
            g.selectAll(".custom-handle-circle").attr("r", 3.5).attr("stroke-width", "1");
            g.selectAll(".drag-label").attr("fill-opacity", 0).attr("transform", "translate(0,0)");
            g.selectAll(".drag-label-mask").attr("visibility", "hidden").attr("transform", "translate(0,0)");;
            g.selectAll(".custom-handle-line").attr("fill-opacity", 0);

            if (categoryIndex != null){
                getNthElement(g.selectAll(".custom-handle-circle"), categoryIndex).attr("r", 4.5).attr("stroke-width", 3);
                getNthElement(g.selectAll(".custom-handle-circle"), categoryIndex+1).attr("r", 4.5).attr("stroke-width", 3);
                getNthElement(g.selectAll(".custom-handle-line"), categoryIndex).attr("fill-opacity", 1);
                getNthElement(g.selectAll(".custom-handle-line"), categoryIndex+1).attr("fill-opacity", 1);
                
                var dragLabel1 = getNthElement(g.selectAll(".drag-label"), categoryIndex);
                var dragLabel2 = getNthElement(g.selectAll(".drag-label"), categoryIndex + 1);
                var dragMask1 = getNthElement(g.selectAll(".drag-label-mask"), categoryIndex);
                var dragMask2 = getNthElement(g.selectAll(".drag-label-mask"), categoryIndex + 1);

                dragMask1.attr("visibility", "visible");
                dragMask2.attr("visibility", "visible");     

                dragLabel1.attr("fill-opacity", 1);
                dragLabel2.attr("fill-opacity", 1);           

                // handle conflicting labels
                var dragLabel1Box = dragLabel1.node().getBBox();
                var dragLabel2Box = dragLabel2.node().getBBox();

                // calculate conflict number
                var conflictDiff = dragLabel2Box.x - (dragLabel1Box.x + dragLabel1Box.width)-maskPadding;
                // and handle if there is not enough space
                if (conflictDiff<0){
                    // pos1 diff to the left
                    var posDiff1 = conflictDiff/2;
                    // pos2 diff to to right
                    var posDiff2 = conflictDiff/2;

                    // position left to 0 if position would be lower than 0
                    var xMin = dragLabel1Box.x+posDiff1;
                    if (xMin < 0){
                        posDiff1 = 0.5 - dragLabel1Box.x; 
                        // also shift right label so we keep it visible
                        posDiff2 = posDiff2*2
                    }

                    // same with max value
                    var xMax = dragLabel2Box.x+dragLabel2Box.width-posDiff2;
                    if (xMax > width){
                        posDiff2 += xMax-width-0.5; 
                        posDiff1 = posDiff1*2
                    }                    

                    // shift labels and masks to handle conflicts
                    dragLabel1.attr("transform", "translate("+posDiff1+", 0)")
                    dragLabel2.attr("transform", "translate("+-posDiff2+", 0)")
                    dragMask1.attr("transform", "translate("+posDiff1+", 0)")
                    dragMask2.attr("transform", "translate("+-posDiff2+", 0)")
                }
            }
        }

        function handleHoverState(g, x){
            g.selectAll(".selectionbar").on("mouseout", onMouseOut);
            g.selectAll(".selectionbar").on("mouseover", function(d, i, nodes){
                d3.select(nodes[i]).attr("fill", "rgba(0,0,0,0.00)")
                var categoryIndex = parseInt(d3.select(d3.event.target).attr("data-category-index"));
                if (overCategoryIndex != categoryIndex){
                    overCategoryIndex = categoryIndex;
                    updateSelection(g, x);
                    updateSelectionControlsHoverState(g, categoryIndex);
                    fireEvent("selectionHoverChange", overCategoryIndex);
                }
            })

            function onMouseOut(d, i, nodes){
                d3.select(nodes[i]).attr("fill", "rgba(0,0,0,0)")
                overCategoryIndex = null;
                updateSelectionControlsHoverState(g, null);
                updateSelection(g, x);
                fireEvent("selectionHoverChange", overCategoryIndex);
            }

        }

        /**
        * Returns bar color based on X position
        * @returns {String} color
        */
        function getBarCategoryIndex(barX){
            for (var i=0;i<selection.length;i++){
                var s = selection[i];
                var within = barX >= valueToPosition(s.from) && barX < valueToPosition(s.to);
                if (within) return i;
            }

            return null;
        }

        /**
        * Renders selection
        * @param {d3.Selection} g
        * @param {d3.Axis} x
        */
        function updateSelection(g, x){
            // handle bar colors
            g.selectAll(".bar").attr("fill", function (d) {
                var barX = valueToPosition(d.value);
                var barCategoryIndex = getBarCategoryIndex(barX);
                if (barCategoryIndex == null){
                    return inactiveCategoryColor;
                } else if (selection[barCategoryIndex].disabled){
                    return inactiveCategoryColor;
                } if (overCategoryIndex == barCategoryIndex){
                    return hoverCategoryColor;
                } else {
                    return selection[barCategoryIndex].color;                    
                }
            });

        // space filling rectangles
            g.selectAll(".selectionbar")
                .data(selection)
                .attr("data-category-index", function(d,i){
                    return i;
                })
                .attr("x", function (d) { 
                    return valueToPosition(d.from);
                })
                .attr("width", function(d){
                    return valueToPosition(d.to) - valueToPosition(d.from);
                })
        }

        /**
        * Updates selectino with new positions
        * @param {Array} positions
        * @param {d3.Selection} g
        * @param {d3.Axis} x
        */
        function updateSelectionPositions(positions, g, x){
            positions.forEach((p, index)=>{
                if (index>selection.length-1){
                    return;
                }
                selection[index].from = positionToValue(p);
                selection[index].to = positionToValue(positions[index+1]);
            });

            updateSelection(g, x);
        }

        /**
        * @param {d3.Selection} g
        * @param {int} position  
        * Creates drag handle
        */
        function createHandle(g, value, x, handleIndex){
            var position = valueToPosition(value);   
            // handle
            var handle = g.append("rect")
            .attr("class", "custom-handle")
            .attr("fill-opacity", 0)
            .attr("data-handle-index", handleIndex)
            .attr("data-handle-value", value)
            .attr("cursor", "ew-resize")
            .attr("width",10)
            .attr("height", height+5)
            .attr("x", position-5);

            // handle line decorator
            var line = g.append("rect")
            .attr("class", "custom-handle-line")
            .attr("width",4)
            .attr("height", height)
            .attr("fill-opacity", 0)
            .attr("x", position-2);

            // circle decorator
            var circle = g.append("circle")
                .attr("class", "custom-handle-circle")
                .attr("transform", "translate(" + position + "," + height + ")")
                .attr("fill", "#ffffff")
                .attr("fill-opacity", 1)
                .attr("stroke", "#000")
                .attr("stroke-width", 1)
                .attr("cursor", "ew-resize")
                .attr("r",3.5); 

            
            // drag mask, we need this in order to mask min/max values when drag label is over min/max labels
            var dragMask = g.append("rect")
                .attr("class", "drag-label-mask")
                .attr("fill", "url(#brush-mask-gradient-"+handleIndex+")")
                .attr("y", height+12)
                .attr("visibility", "hidden");          

            var maskGradient = g.append("linearGradient")
                .attr("id", "brush-mask-gradient-"+handleIndex)
                .attr("gradientUnits", "userSpaceOnUse")
                .attr("y1", 0).attr("x1", 50)
                .attr("y2", 0).attr("x2", 0);

                maskGradient.selectAll("stop")
                .data([
                    {offset: "0%", color: "rgba(255,255,255,0)"},
                    {offset: "10%", color: "rgba(255,255,255,1)"},
                    {offset: "90%", color: "rgba(255,255,255,1)"},
                    {offset: "100%", color: "rgba(255,255,255,0)"}
                ])
                .enter().append("stop")
                .attr("offset", function(d) { return d.offset; })
                .attr("stop-color", function(d) { return d.color; });  

            // drag label
            var dragLabel = g.append("text")
                .attr("class", function (d) {
                    return "drag-label";
                })
                .attr("fill-opacity", 0)
                .text(function(d, i){
                    return format(positionToValue(position));
                }).attr("x", function(){
                    return updateLabelPosition(this, position);
                }).attr("y", height+22);          
            
            // handle hover state
            var isOver = false;
            function setOverState(){
                line.attr("fill-opacity", 1);
                dragLabel.attr("fill-opacity", 1);
                dragMask.attr("visibility", "visible");
                circle.attr("r", 4.5).attr("stroke-width", 3);
            }

            function unsetOverState(){
                line.attr("fill-opacity", 0);
                dragLabel.attr("fill-opacity", 0);
                dragMask.attr("visibility", "hidden");
                circle.attr("r", 3.5).attr("stroke-width", 1);
            }

            // line hover effect
            handle.on("mouseover", ()=>{
                isOver = true;
                setOverState();
            })
            handle.on("mouseout", ()=>{
                isOver = false;
                unsetOverState();
            })                

            // handle drag
            handle.call(d3.drag()
                .on("drag", drag)
                .on("start", startdrag)
                .on("end", enddrag));

            function startdrag(){
                g.classed("dragging", true);
                g.selectAll(".custom-handle, .custom-handle-circle, .custom-handle-line, .bar, .selectionbar").attr("pointer-events", "none");

                handle.attr("pointer-events", "all");
                line.attr("pointer-events", "all");
                circle.attr("pointer-events", "all");
            }

            function enddrag(){
                g.classed("dragging", false);
                g.selectAll(".custom-handle, .custom-handle-circle, .custom-handle-line, .bar, .selectionbar").attr("pointer-events", "all");

                if (!isOver){
                    unsetOverState();
                }
            }

            function updateLabelPosition (label, position) {
                // we need to calculate text length so we can create mask and center text
                var textLength = label.getComputedTextLength();
                var maskWidth = textLength + maskPadding*2;
                var xPosition = position-textLength/2;

                // handle when dragging towards left side
                if(xPosition <0){
                    xPosition = 0.5;
                }

                // handle when dragging towards right side
                if(xPosition+textLength >360){
                    xPosition = 360-textLength+0.5;
                }

                // position mask
                dragMask.attr("x", (d, i)=>{
                    return parseInt(xPosition) - maskPadding; 
                });
                
                maskGradient.attr("x1", xPosition-maskPadding);
                maskGradient.attr("x2", xPosition+maskWidth-maskPadding);

                dragMask.attr("width", maskWidth);
                dragMask.attr("height", 20);         

                // position text
                return xPosition; 
            };

            function drag() {
               var xpos = Math.round(Math.max(Math.min(d3.event.x, width), 0));
               handle.attr("x", xpos-5);
               line.attr("x", xpos-2);
               circle.attr("transform", "translate(" + xpos + "," + height + ")");
               handle.attr("data-handle-value", positionToValue(xpos))

               setOverState();

               var positions = g.selectAll(".custom-handle").nodes().map(handle=>{
                   return Math.round(d3.select(handle).attr("x"))+5;
               }).sort((p1, p2)=>{
                   return p1-p2;
               });

               updateSelectionPositions(positions, g, x);

               dragLabel.text(function(){
                    return format(positionToValue(xpos));
                }).attr("x", function(){
                    return updateLabelPosition(this, xpos);
                });  
                      
            }
        }

        function getSelectionPoints(){
            var result = [];
            selection.forEach((s, index)=>{
                result.push(s.from);
                if (index == selection.length-1){
                    result.push(s.to);
                }
            });

            return result;
        }

        /**
        * Renders selection
        * @param {d3.Selection} g
        * @param {d3.Axis} x
        * @param {Array} data
        */
        function updateSelectionControls(g, x, data){
            getSelectionPoints().forEach((point, index)=>{
                createHandle(g, point, x, index);
            });
        }

        /**
        * Destroy controls
        * @param {d3.Selection} g
        */
        function destroySelectionControls(g){
            g.selectAll(".custom-handle, .custom-handle-circle, .custom-handle-line, .drag-label,.drag-label-mask").remove();
        }

        /**
        * Returns min max values for given data
        * @param {Array} data
        * @returns {Object} minMax.min
        * @returns {Object} minMax.max
        */
        function getXMinMax(data){
            var min = d3.min(data, function (d) { return d.value; });
            var max = d3.max(data, function (d) { return d.value; });

            return {
                min:min,
                max:max
            }
        }    

        /**
        * @param {d3.Selection} g
        * @param {int} width
        * @param {int} height
        * @param {int} margin
        * @return {d3.Selection} 
        */
        function render(width, height, margin){
            var svgEl = d3.select(container).append("svg")
                .attr("width", width + margin * 2)
                .attr("height", height + margin * 2);

            var groupEl = svgEl.append("g")
                .classed("inactive", true)
                .attr("transform",
                "translate(" + margin + "," + margin + ")");

            svgEl.on("mouseover.hover", ()=>{
                groupEl.classed("active", true)
                groupEl.classed("inactive", false)
            })

            svgEl.on("mouseout.hover", ()=>{
                groupEl.classed("inactive", true)
                groupEl.classed("active", false)
            })

            return groupEl;
        };

        /**
        * @param {Array} buckets
        * @param {int} numOfBarsPerBucket - number of bars per column\
        * @returns {Array} data from given buckets 
        */
        function getData(buckets, numOfBarsPerBucket){
            var data = [];
            var numOfBarsPerBucket = width / buckets.length;
            buckets.forEach((bucket) => {
                var step = (bucket.max - bucket.min) / numOfBarsPerBucket;
                d3.range(bucket.min, bucket.max, step).forEach((value) => {
                    data.push({
                        value: value*100000,
                        volume: bucket.content[0].frequency
                    });
                });
            });
            return data;
        };            

        /**
        * @param {d3.Selection} g
        * @param {Array} data
        * @param {d3.Axis} x
        * @param {d3.Axis} y
        * @return {d3.Selection} 
        */
        function renderBars(g, data, x, y) {
            // Scale the range of the data in the domains
            x.domain(data.map(function (d) {return d.value; }));
            y.domain([0, d3.max(data, function (d) { return d.volume; })]);

            // append the rectangles for the bar chart
            var bar = g.selectAll(".bar")
                .data(data)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", function (d) { return x(d.value); })
                .attr("width", x.bandwidth())
                .attr("y", function (d) { return Math.round(y(d.volume)); })
                .attr("height", function (d) { return Math.round(height - y(d.volume)); });

            // hover selection bars
            g.selectAll(".selectionbar")
                .data(selection)
                .enter().append("rect")
                .attr("class", "selectionbar")
                .attr("y", 0)
                .attr("fill", "rgba(0,0,0,0.00)")
                .attr("height", height);                

            return bar;
        };        
        
        /**
        * @param {d3.Selection} g
        * @param {Array} data
        * @param {d3.axis} x
        * @return {d3.Selection} 
        */        
        function renderXAxis(g, data, x){
            // calculate min max as these are the only values shown on axis
            var xMin = d3.min(data, function (d) { return d.value; });
            var xMax = d3.max(data, function (d) { return d.value; });

            // create bottom axis
            var axis = d3.axisBottom(x)
                .tickValues([xMin, xMax])
                .tickSize(0)
                .tickFormat(format)
                .tickPadding(15);

            var axisGroup = g.append("g")
                .attr("transform", "translate(0," + height + ")")
                .attr("class", "x-axis")
                .call(axis);

            axisGroup.selectAll(".tick").attr("transform", function(d, i){
                var textLength = d3.select(this).select("text").node().getComputedTextLength();
                if (i == 0){
                    return "translate("+textLength/2+",0)"
                }

                if (i == 1){
                    return "translate("+(width-textLength/2)+",0)"
                }
            })
        }

    </script>
</body>